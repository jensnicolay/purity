(random-seed 111) ; deterministic random
(define CESK-TIMELIMIT (make-parameter 2)) ; timeout in minutes

(define %random (lambda (n) (if (zero? n) 0 (random n))))

(define (index v x)
  (let ((i (vector-member x v)))
    (if i
        i
        (let ((i (add1 (vector-ref v 0))))
          (vector-set! v 0 i)
          (vector-set! v i x)
          i))))
;(define frameis (make-vector 1000))
;(define (frame->framei frame) (index frameis frame))
(define ctxis (make-vector 1000))
(define (ctx->ctxi ctx) (index ctxis ctx))
;(define stateis (make-vector 1000))
;(define (state->statei q) (index stateis q))
;(define storeis (make-vector 1000))
;(define (store->storei σ) (index storeis σ))

;; domain helpers
(define (env-lookup ρ x)
  (hash-ref ρ x))
(define (env-addresses ρ)
  (list->set (hash-values ρ)))
(define (store-lookup σ a)
  (hash-ref σ a))
(define (store-⊒ σ1 σ2 ⊒)
  (if (eq? σ1 σ2)
      #t
      (if (< (hash-count σ1) (hash-count σ2))
          #f
          (for/and (((k v) σ1))
            (and (hash-has-key? σ2)
                 (⊒ v (hash-ref σ2 k)))))))
(define (stack-lookup Ξ τ)
  (hash-ref Ξ τ))
;;

;; machine
(struct ev (e ρ ι κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "EV ~a\nρ ~a\nι ~a\nκ ~a" (ev-e v) (ev-ρ v) (ev-ι v) (ev-κ v))))
(struct ko (ι κ v) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "KO ι ~a\nκ ~a\nv ~a" (ko-ι v) (ko-κ v) (ko-v v))))
(struct letk (x e ρ) #:transparent)
(struct letreck (a e ρ) #:transparent)
(struct haltk () #:transparent)
(struct clo (λ ρ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<clo ~a>" («lam»-l (clo-λ v)))))
(struct prim (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                        (equal? (prim-name s1) (prim-name s2))))
                                                   (define hash-proc (lambda (s rhash) (equal-hash-code (prim-name s))))
                                                   (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim-name s))))))
(struct prim2 (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                         (equal? (prim2-name s1) (prim2-name s2))))
                                                    (define hash-proc (lambda (s rhash) (equal-hash-code (prim2-name s))))
                                                    (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim2-name s))))))
(struct addr (a) #:transparent)
(struct system (states duration initial graph Ξ lattice context answer? exit msg) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<sys #~a ~a ~a>" (vector-length (system-states v)) (system-exit v) (~a (system-msg v) #:max-width 70))))

(struct context (kalloc e A))

(struct wv (a x) #:transparent)
(struct rv (a x) #:transparent)
(struct wp (a n x) #:transparent)
(struct rp (a n x) #:transparent)
(struct fr () #:transparent)


(define (touches d)
  (if (set? d)
      (for/fold ((as (set))) ((v d)) (set-union as (touches v)))
      (match d
        ((clo _ ρ) (env-addresses ρ))
        ((letk _ _ ρ) (env-addresses ρ))
        ((letreck _ _ ρ) (env-addresses ρ))
        ((addr a) (set a))
        ((cons x y) (set-union (touches x) (touches y)))
        (_ (set)))))
(define (reachable A σ γ)
  (let loop ((A A) (R (set)))
    (if (set-empty? A)
        R
        (let ((a (set-first A)))
          (if (set-member? R a)
              (loop (set-rest A) R)
              (let* ((v (γ (store-lookup σ a)))
                     (T (touches v)))
                (loop (set-union (set-rest A) T) (set-add R a))))))))
;(define (gc s Ξ γ ctx-A)
;  (match s
;    ((ev e ρ σ ι κ)
;     (let* ((ρ* (↓ ρ (free e)))
 ;           (R (reachable (set-union (env-addresses ρ*) (stack-addresses ι κ ctx-A)) σ γ))
;            (σ* (↓ σ R)))
;       (ev e ρ* σ* ι κ)))
;    ((ko ι κ v σ)
;     (let* ((R (reachable (set-union (touches v) (stack-addresses ι κ ctx-A)) σ γ))
;            (σ* (↓ σ R)))
;       (ko ι κ v σ*)))))
(define (stack-frames ι κ Ξ)
  (let loop ((todo (set (cons ι κ))) (result (set)) (seen (set)))
    (if (set-empty? todo)
        result
        (match-let (((cons ι κ) (set-first todo)))
          (let* ((result* (set-union result (list->set ι))))
            (if (or (not κ) (set-member? seen κ))
                (loop (set-rest todo) result* seen)
                (let ((ικs (stack-lookup Ξ κ)))
                  (loop (set-union (set-rest todo) ικs) result* (set-add seen κ)))))))))
(define (stack-pop ι κ Ξ G)
  (if (null? ι)
      (if (set-member? G κ)
          (set)
          (let ((ικs (stack-lookup Ξ κ)))
            (apply set-union (set-map ικs (lambda (ικ) (stack-pop (car ικ) (cdr ικ) Ξ (set-add G κ)))))))
      (set (list ι κ G)))) 
(define (stack-contexts κ Ξ)
  (let loop ((todo (set (cons #f κ))) (seen (set)))
    (if (set-empty? todo)
        seen
        (let ((κ (cdr (set-first todo))))
          (if (or (not κ) (set-member? seen κ))
              (loop (set-rest todo) seen)
              (loop (set-union (set-rest todo) (stack-lookup Ξ κ)) (set-add seen κ)))))))
(define (stack-addresses ι κ ctx-A)
  (for/fold ((A (if κ (ctx-A κ) (set)))) ((φ ι))
    (set-union A (touches ι))))

(struct ctx (e ρ) #:transparent)
(define (make-machine lattice alloc)

  (define α (lattice-α lattice))
  (define γ (lattice-γ lattice))
  (define ⊥ (lattice-⊥ lattice))
  (define ⊔ (lattice-⊔ lattice))
  (define true? (lattice-true? lattice))
  (define false? (lattice-false? lattice))
  (define α-eq? (lattice-eq? lattice))
  
  (define (explore e)
    (define σ (make-hash))
    (define σi 0)
    (define Ξ (make-hash))
    (define poppers (make-hash))
    
    (include "primitives.rkt")
    
    (define (inject e)
      (let ((global* (append (lattice-global lattice)
                             `(("eq?" . ,(α (prim "eq?" prim-eq?)))
                               ("~a" . ,(α (prim "~a" prim-to-string)))
                               ("error" . ,(α (prim "error" prim-error)))
                               ("pair?" . ,(α (prim "pair?" prim-pair)))
                               ("cons" . ,(α (prim "cons" prim-cons)))
                               ("car" . ,(α (prim "car" prim-car)))
                               ("set-car!" . ,(α (prim "set-car!" prim-set-car!)))
                               ("cdr" . ,(α (prim "cdr" prim-cdr)))
                               ("set-cdr!" . ,(α (prim "set-cdr!" prim-set-cdr!))))))
            (compiled-e (compile e)))
        (set! conc-alloc-counter 0)
        (let loop ((global global*) (ρ (hash)))
          (match global
            ('()
             (let* ((ρ* (↓ ρ (free compiled-e)))
                    (R (reachable (env-addresses ρ*) σ γ))
                    (σ* (↓ σ R)))
               (set! σ (make-hash (hash->list σ*))) ; TODO (ugly?)
               (ev compiled-e ρ* `(,(haltk)) #f)))
            ((cons (cons x v) r)
             (let ((a (conc-alloc)))
               (hash-set! σ a v)
               (loop r (hash-set ρ x a))))))))
    
    ;(define (stack-to-string stack)
    ;  (cons (map frame->framei (car stack)) (ctx->ctxi (cdr stack))))
    
    (define (env-bind ρ x a)
      (hash-set ρ x a))
    
    (define (store-alloc! a v)
      (if (hash-has-key? σ a)
          (let* ((current (hash-ref σ a))
                 (updated (⊔ current v)))
            (unless (equal? current updated)
              (hash-set! σ a updated)
              (set! σi (add1 σi))))
          (hash-set! σ a v)))
          
    (define (store-update! a v)
      (let* ((current (hash-ref σ a))
             (updated (⊔ current v)))
        (unless (equal? current updated)
          (hash-set! σ a updated)
          (set! σi (add1 σi)))))
      
    (define (stack-alloc! κ stack)
      ;(printf "allocing ctx ~a stack ~a " (ctx->ctxi τ) (stack-to-string stack))
      (let ((stacks (hash-ref Ξ κ #f)))
        (if stacks
            (unless (set-member? stacks stack)
              ;(printf "ADDING to ~a\n" (set-map stacks stack-to-string))
              (hash-set! Ξ κ (set-add stacks stack))
              (for ((s (hash-ref poppers κ (set))))
                (set-remove! visited s)
                (set! todo (set-add todo s))))
            (hash-set! Ξ κ (set stack)))))
    
    (define (alloc-literal! e)
      (if (pair? e)
          (let ((car-v (alloc-literal! (car e))))
            (let ((cdr-v (alloc-literal! (cdr e))))
              (let ((a (alloc e e)))
                (store-alloc! a (α (cons car-v cdr-v)))
                (α (addr a)))))
          (α e)))
    
    (define (eval-atom ae ρ)
      (match ae
        ((«lit» _ v)
         (values (α v) (set)))
        ((«id» _ x)
         (let ((a (env-lookup ρ x)))
           (values (store-lookup σ a) (set (rv a ae)))))
        ((«lam» _ x e)
         (let ((cl (clo ae ρ)))
           (values (α cl) (set))))
        ((«quo» _ atom)
         (values (α atom) (set)))
        (_ (error "cannot handle ae" ae))))

    (struct transition (s E))
    
    (define (apply-let-kont x e ρ ι κ v E)
      (let* ((a (alloc x (and κ (ctx-e κ))))
             (ρ* (env-bind ρ («id»-x x) a)))
        (store-alloc! a v)
        (set (transition (ev e ρ* ι κ) E))))
    (define (apply-letrec-kont x e ρ ι κ v E)
      (let* ((a (env-lookup ρ («id»-x x))))
        (store-update! a v)
        (set (transition (ev e ρ ι κ) E))))
    (define (apply-local-kont ι κ v E)
      (match ι
        ((cons (letk x e ρ) ι)
         (apply-let-kont x e ρ ι κ v E))
        ((cons (letreck x e ρ) ι)
         (apply-letrec-kont x e ρ ι κ v E))
        (_ (set (transition (ko ι κ v) E)))))
    
    ;(define (print-state q)
    ;  (match q
    ;   ((ev e ρ σ ι κ m) (printf "EV ~a\nρ ~a σ ~a\nι ~a κ ~a frames ~a\n" (~a e #:max-width 40) ρ (store->storei σ) (map frame->framei ι) (ctx->ctxi κ) (set-map (stack-frames ι κ Ξ) frame->framei)))
    ;    ((ko ι κ v σ m) (printf "KO ~a σ ~a\nι ~a κ ~a frames ~a\n" v (store->storei σ) (map frame->framei ι) (ctx->ctxi κ) (set-map (stack-frames ι κ Ξ) frame->framei)))))
    
    (define (step q)
      ;(check-safety q Ξ)
      (match q
        ((ev (? ae? ae) ρ ι κ)
         (let-values (((v E) (eval-atom ae ρ)))
           (set (transition (ko ι κ v) E))))
        ((ev («if» _ ae e1 e2) ρ ι κ)
         (let-values (((v E) (eval-atom ae ρ)))
           (set-union (if (true? v)
                          (if (ae? e1)
                              (let-values (((v* E*) (eval-atom e1 ρ)))
                                (set (transition (ko ι κ v*) (set-union E E*))))
                              (set (transition (ev e1 ρ ι κ) E)))
                          (set))
                      (if (false? v)
                          (if (ae? e2)
                              (let-values (((v* E*) (eval-atom e2 ρ)))
                                (set (transition (ko ι κ v*) (set-union E E*))))
                              (set (transition (ev e2 ρ ι κ) E)))
                          (set)))))
        ((ev («let» _ x e0 e1) ρ ι κ)
         (if (ae? e0)
             (let-values  (((v E) (eval-atom e0 ρ)))
               (apply-let-kont x e1 ρ ι κ v E))
             (set (transition (ev e0 ρ (cons (letk x e1 ρ) ι) κ) (set)))))
        ((ev («letrec» _ x e0 e1) ρ ι κ)
         (let* ((a (alloc x (and κ (ctx-e κ))))
                (ρ* (env-bind ρ («id»-x x) a)))
           (store-alloc! a ⊥)
           (if (ae? e0)
               (let-values (((v E) (eval-atom e0 ρ*)))
                 (apply-letrec-kont x e1 ρ* ι κ v E))
               (set (transition (ev e0 ρ* (cons (letreck x e1 ρ*) ι) κ) (set))))))
        ((ev («set!» _ x ae) ρ ι κ)
         (let-values (((v E) (eval-atom ae ρ)))
           (let* ((a (env-lookup ρ («id»-x x))))
             (store-update! a v)
             (set (transition (ko ι κ v) (set-add E (wv a x)))))))
        ((ev («quo» _ e) ρ ι κ)
         (let ((v (alloc-literal! e)))
           (set (transition (ko ι κ v) (set)))))
        ((ev (and («app» _ rator rands) e) ρ ι κ)
         (let-values (((v E) (eval-atom rator ρ)))
           (let rands-loop ((rands rands) (rvs '()) (E E))
             (if (null? rands)
                 (for/fold ((succ (set))) ((w (γ v)))
                   (match w
                     ((clo (and λ («lam» _ x e0)) ρ**)
                        (define (bind-loop x vs ρ*)
                          (match x
                            ('()
                             (let ((κ* (ctx e0 ρ*)))
                               (stack-alloc! κ* (cons ι κ))
                               (set-add succ (transition (ev e0 ρ* '() κ*) E))))
                            ((cons x xs)
                             (if (null? vs)
                                 (set)
                                 (let ((a (alloc x e)))
                                   (store-alloc! a (car vs))
                                   (bind-loop xs (cdr vs) (env-bind ρ* («id»-x x) a)))))))                        
                        (bind-loop x (reverse rvs) ρ**))
                     ((prim name proc)
                      (set-union succ (list->set (set-map (proc e (reverse rvs) ι κ Ξ) (lambda (vE) (transition (ko ι κ (car vE)) (set-union E (cadr vE))))))))
                     ((prim2 _ proc)
                      (set-union succ (set (transition (ko ι κ (apply proc (reverse rvs))) E))))
                     (_ (set))))
                 (let-values (((v E*) (eval-atom (car rands) ρ)))
                   (rands-loop (cdr rands) (cons v rvs) (set-union E E*)))))))
        ((ko (cons (haltk) _) #f v)
         (set))
        ((ko ι κ v)
         (if (eq? v ⊥)
             (set)
             (let* ((ικGs (stack-pop ι κ Ξ (set))))
               (let loop ((ικGs ικGs) (succ (set)))
                 (if (set-empty? ικGs)
                     succ
                     (let* ((ικG (set-first ικGs))
                            (ι (car ικG))
                            (κ (cadr ικG))
                            (G (caddr ικG))
                            (succ* (apply-local-kont ι κ v (set))))
                       (for ((κ G))
                         (hash-set! poppers κ (set-add (hash-ref poppers κ (set)) q)))
                       (loop (set-rest ικGs)
                             (set-union succ succ*))))))))
        )) ; end step
    
    (define visited (mutable-set))
    (define graph (make-hash))
    (define states (mutable-set))
    (define initial (inject e))
    (define todo (set initial))
    (define (make-system duration exit msg)
      (system (list->vector (set->list states)) duration initial graph Ξ lattice context answer? exit msg))
    
    ;(define state-limit (STATELIMIT))
    (define time-limit (+ (current-milliseconds) (* (CESK-TIMELIMIT) 60000)))
    
    (let ((start (current-milliseconds)))
      (let explore-loop ()
        (if (and (zero? (remainder (set-count states) 10000))
                 (> (current-milliseconds) time-limit))
            (make-system (- (current-milliseconds) start) 'user "time out")
            (if (set-empty? todo)
                (make-system (- (current-milliseconds) start) 'ok "")
                (let* ((q (set-first todo)))
                  (set! todo (set-rest todo))
                  (if (set-member? visited q)
                      (explore-loop)
                      (let ((old-σi σi))
                        ;(printf "q ~a\n" (state->statei q))
                        (set-add! visited q)
                        (set-add! states q)
                        (let succ-loop ((succs (step q)) (new-states (set)) (succs-gc (set)))
                          (if (set-empty? succs)
                              (let* ((existing (hash-ref graph q (set)))
                                     (updated (set-union existing succs-gc)))
                                (hash-set! graph q updated)
                                ;(when (> (set-count updated) 3)
                                ;  (printf "~a has ~a succs\n" (state-repr q) (set-count updated))
                                ;  (for ((succ updated))
                                ;    (printf "\t~a\n" (state-repr (car succ))))
                                ;)
                                (set! todo (set-union new-states todo))
                                (when (> σi old-σi)
                                  (set-clear! visited))
                                (explore-loop))
                              (match (set-first succs)
                                ((transition s E)
                                 (succ-loop (set-rest succs) (set-add new-states s) (set-add succs-gc (cons s E))))))))))))))
  ) ; end explore  
(define (answer? s)
  (match s
    ((ko (cons (haltk) _) _ v) #t)
    (_ #f)))

explore)

(define (answer-set sys)
  (let ((answer? (system-answer? sys)))
    (for/fold ((v (set))) ((s (system-states sys)))
      (if (answer? s)
          (set-add v s)
          v))))

(define (answer-value sys)
  (let* ((lattice (system-lattice sys))
         (⊥ (lattice-⊥ lattice))
         (⊔ (lattice-⊔ lattice)))
    (for/fold ((v ⊥)) ((s (answer-set sys)))
      (⊔ v (ko-v s)))))
;;

;; allocators
(define conc-alloc-counter 0)
(define conc-alloc
  (lambda _
    (set! conc-alloc-counter (add1 conc-alloc-counter))
    conc-alloc-counter))

(define (mono-alloc x _)
  x)

(define (poly-alloc x ctx)
  (cons x ctx))
;  (cons x (if ctx
;              (clo-λ (ctx-clo ctx))
;              ctx)))
;;
