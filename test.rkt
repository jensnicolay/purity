(define (add-append e)
  `(letrec ((append (lambda (l1 l2)
                      (let ((_a_t1 (null? l1)))
                        (if _a_t1
                            l2
                            (let ((_a_t2 (car l1)))
                              (let ((_a_t3 (cdr l1)))
                                (let ((_a_t4 (append _a_t3 l2)))
                                  (cons _a_t2 _a_t4)))))))))
     ,e))

(define (add-equal? e)
  `(letrec ((equal? (lambda (x1 x2)
                      (let ((_b_t2 (pair? x1)))
                        (if _b_t2
                            (let ((_b_t3 (pair? x2)))
                              (if _b_t3
                                  (let ((_b_t4 (car x1)))
                                    (let ((_b_t5 (car x2)))
                                      (let ((_b_t6 (equal? _b_t4 _b_t5)))
                                        (if _b_t6
                                            (let ((_b_t7 (cdr x1)))
                                              (let ((_b_t8 (cdr x2)))
                                                (equal? _b_t7 _b_t8)))
                                            #f))))
                                  #f))
                            (eq? x1 x2))))))
     ,e))
;; Free variables: list set-car! set-cdr!
(define (add-cars e)
  `(let ((cadr (lambda (p) (let ((_p0 (cdr p))) (car _p0)))))
     (let ((caar (lambda (p) (let ((_p0 (car p))) (car _p0)))))
       (let ((cddr (lambda (p) (let ((_p0 (cdr p))) (cdr _p0)))))
         (let ((caadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (car _p1))))))
           (let ((cdadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (cdr _p1))))))
             (let ((caddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (car _p1))))))
               (let ((cdddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (cdr _p1))))))
                 (let ((cadddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (let ((_p2 (cdr _p1))) (car _p2)))))))
                   ,e)))))))))

(define (add-map e)
  `(letrec ((map (lambda (f l)
                   (let ((_p0 (pair? l)))
                     (if _p0
                         (let ((_p1 (car l)))
                           (let ((_p2 (f _p1)))
                             (let ((_p3 (cdr l)))
                               (let ((_p4 (map f _p3)))
                                 (cons _p2 _p4)))))
                         '())))))
     ,e))

(define (add-length e)
  `(letrec ((length (lambda (l)
                      (let ((_p0 (null? l)))
                        (if _p0
                            0
                            (let ((_p1 (cdr l)))
                              (let ((_p2 (length _p1)))
                                (+ 1 _p2))))))))
     ,e))

(define (add-reverse e)
  `(let ((reverse (lambda (l)
                   (letrec ((reverse-acc (lambda (l acc)
                                           (let ((c (null? l)))
                                             (if c
                                                 acc
                                                 (let ((u (cdr l)))
                                                   (let ((v (car l)))
                                                     (let ((w (cons v acc)))
                                                       (reverse-acc u w)))))))))
                     (reverse-acc l '())))))
    ,e))

(define (add-list? e)
  `(letrec ((list? (lambda (l)
                     (let ((u (null? l)))
                       (if u
                           #t
                           (let ((v (pair? l)))
                             (if v
                                 (let ((w (cdr l)))
                                   (list? w))
                                 #f)))))))
     ,e))

(define p1 '(let ((c (cons 1 #f))) (car c)))
(define p2 '(let ((c (cons 1 #f))) (cdr c)))
(define p3 '(let ((u '(1 2 3))) (let ((v (cdr u))) (car v))))
(define p4 '(let ((x '(1 (2 3)))) (let ((y (cdr x))) (let ((z (car y))) (car z)))))
(define p5 (add-equal? '(let ((x '(1    "ho"))) (let ((y '(1 #f "ho"))) (equal? x y)))))
(define p6 (add-reverse '(let ((x '(1 #f "ho"))) (let ((y (reverse x))) (car y)))))
(define p7 (add-reverse '(let ((xx (cons 2 '()))) (let ((x (cons 1 xx))) (let ((y (reverse x))) (car y))))))
(define p8 (add-equal? '(equal? 1 2)))
(define p9 (add-equal? '(equal? 1 1)))
(define p10 (add-equal? '(let ((xx (cons 2 '()))) (let ((x (cons 1 xx))) (let ((y '(1 2))) (equal? x y))))))
(define p11 (add-append '(let ((x '(1))) (let ((y '(2))) (let ((z (append x y))) (~a z))))))
(define p12 (add-append '(let ((x '(1))) (let ((y '(2 3))) (let ((z (append x y))) (let ((u (cdr z))) (let ((v (car u))) v)))))))
(define p13 '(let ((x '(1 2 3))) (~a x)))
(define p14 (add-append '(let ((x '(1 2 3))) (let ((y '(4 5))) (append x y)))))
(define p15 '(let ((z 123)) (let ((f (lambda () z))) (f))))
(define sq '((lambda (x) (* x x)) 8))
(define loopy1 '(letrec ((f (lambda () (f)))) (f)))
(define loopy2 '((lambda (x) (x x)) (lambda (y) (y y))))
(define safeloopy1 '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)))
(define hellomemo '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))))
(define helloset! '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))))
(define hellomemoset! '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))))
(define fac (file->value "test/fac.scm"))
(define fib (file->value "test/fib.scm"))
(define blur (file->value "test/blur.scm"))
(define eta (file->value "test/eta.scm"))
(define gcipd (file->value "test/gcipd.scm"))
(define kcfa2 (file->value "test/kcfa2.scm"))
(define kcfa3 (file->value "test/kcfa3.scm"))
(define loop2 (file->value "test/loop2.scm"))
(define mj09 (file->value "test/mj09.scm"))
(define rotate (file->value "test/rotate.scm"))
(define sat (file->value "test/sat.scm"))
(define rsa (file->value "test/rsa.scm"))
(define factor (add-reverse (file->value "test/factor.scm")))
(define primtest (file->value "test/primtest.scm"))
(define regex (add-equal? (file->value "test/regex.scm")))
(define cpstak (file->value "test/cpstak.scm"))
(define churchnums (file->value "test/churchnums.scm"))
(define nqueens (add-append (file->value "test/nqueens.scm")))
(define fib-mut (file->value "test/fib-mut.scm"))
(define account (file->value "test/account.scm"))
(define collatz (file->value "test/collatz.scm"))
(define scm2java (add-list? (file->value "test/scm2java.scm")))
(define mceval (add-length (add-cars (add-map (file->value "test/mceval.scm")))))
(define boyer (add-equal? (add-cars (file->value "test/boyer.scm"))))
(define ack (add-equal? (file->value "test/ack.scm")))
(define dderiv (add-equal? (add-cars (add-map (file->value "test/dderiv.scm")))))
(define takl (add-equal? (file->value "test/takl.scm")))
(define divrec (add-cars (add-equal? (file->value "test/divrec.scm"))))
(define sound1 (file->value "test/sound1.scm"))
(define sound2 (file->value "test/sound2.scm"))
(define sound3 (file->value "test/sound3.scm"))
(define sound4 (file->value "test/sound4.scm"))
(define sound5 (file->value "test/sound5.scm"))
(define sound6 (file->value "test/sound6.scm"))
(define sound7 (file->value "test/sound7.scm"))
(define sound8 (file->value "test/sound8.scm"))
(define treenode1 '(let ((tree-node (lambda (l) (let ((this (cons 1 2))) (let ((a this)) (set-car! a l)))))) 
           (letrec ((f (lambda (levels) (let ((left #f)) (let ((c (<= levels 1))) (let ((u (if c (set! left 'null) (let ((n (- levels 1))) (let ((ll (f n))) (set! left ll)))))) (tree-node left)))))))
             (f 3))))
(define destruct (add-length (file->value "test/destruct.scm")))

(define (purity-test)
  (define (test e expected)
    (for ((config (list lsf-config)))
      (match-let (((benchmark-config name mach ctx-λ handler) config))
        (let* ((sys (mach e))
               (initial (system-initial sys))
               (ast (ev-e initial))
               (Ξ (system-Ξ sys))
               (C (purity-analysis sys (handler sys) ctx-λ))
               (Cpop (go->pop C))
               (C* (make-hash (hash-map Cpop (lambda (k v) (cons («lam»-l k) v))))))
          (unless (equal? (make-hash expected) C*)
            (printf "error ~a ~a\n~a ~a\n" name e expected C*))))))
  (test fac '((2 . "PURE")))
  (test fib '((2 . "PURE")))
  (test fib-mut '((2 . "PURE") (12 . "PROC")))
  (test blur '((2 . "PURE") (7 . "PURE") (12 . "PURE")))
  (test eta '((29 . "PURE") (17 . "PURE") (6 . "PURE") (2 . "PURE")))
  (test mj09 '((6 . "PURE") (11 . "PURE") (25 . "PURE") (2 . "PURE")))
  (test gcipd '((2 . "PURE") (7 . "PURE") (35 . "PURE")))
  (test kcfa2 '((2 . "PURE") (6 . "PURE") (10 . "PURE")))
  (test kcfa3 '((2 . "PURE") (6 . "PURE") (10 . "PURE") (14 . "PURE")))
  (test rotate '((2 . "PURE")))
  (test loop2 '((2 . "PURE") (16 . "PURE") (57 . "PURE")))
  (test '(let ((z #f)) (let ((f (lambda () (set! z #t)))) (f))) '((5 . "PROC")))
  (test '(let ((z #f)) (let ((h (lambda () (set! z #t)))) (let ((g (lambda () (h)))) (let ((f (lambda () (g)))) (f))))) '((5 . "PROC") (11 . "PROC") (16 . "PROC")))
  (test '(let ((z #f)) (let ((f (lambda () (let ((g (lambda () (let ((h (lambda () (set! z #t)))) (h))))) (g))))) (f))) '((5 . "PROC") (8 . "PROC") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((z #f)) (let ((g (lambda () (let ((h (lambda () (set! z #t)))) (h))))) (g)))))) (f)) '((2 . "PURE") (8 . "PROC") (11 . "PROC")))
  (test '(letrec ((f (lambda () (let ((z #f)) (let ((g (lambda () (let ((u (set! z #t))) (f))))) (g)))))) (f)) '((2 . "PURE") (8 . "PROC")))
  (test '(letrec ((f (lambda () (let ((z #f)) (let ((g (lambda () (set! z #t)))) (let ((u (g))) (f))))))) (f)) '((2 . "PURE") (8 . "PROC")))
  (test '(let ((f (lambda (x) (let ((xx #f)) (let ((u (set! xx x))) xx))))) (let ((v (f 123))) (f v))) '((2 . "PURE")))
  (test '(letrec ((f (lambda (n) (let ((m (- n 1))) (f m))))) (f 123)) '((2 . "PURE")))
  (test '(letrec ((f (lambda (n) (let ((m (- n 1))) (let ((u (set! n m))) (f n)))))) (f 123)) '((2 . "PURE")))
  (test '(letrec ((f (lambda (n) (let ((u (set! n 333))) (f n))))) (f 123)) '((2 . "PURE")))
  (test '(letrec ((f (lambda (n) (let ((u (set! n 333))) (f n))))) (f 123)) '((2 . "PURE")))
  (test '(let ((z #f)) (let ((f (lambda () z))) (let ((u (f))) (set! z #t)))) '((5 . "PURE")))
  (test '(let ((z #f)) (let ((f (lambda () z))) (let ((u (f))) (let ((v (set! z #t))) (f))))) '((5 . "OBS")))
  (test '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((u (g))) (let ((v (set! x 5))) (g)))))))) (f)) '((2 . "PURE") (8 . "OBS")))
  (test '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((uu x)) (let ((u (g))) (let ((v (set! x 5))) (g))))))))) (f)) '((2 . "PURE") (8 . "OBS")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (set-car! o 3))))) (f)) '((2 . "PURE")))
  (test '(let ((f (lambda () (let ((g (lambda () (cons 1 2)))) (let ((o (g))) (car o)))))) (f)) '((2 . "PURE") (5 . "PURE")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (set-car! o 3))))) (f)) '((2 . "PURE")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (set-cdr! o 3))))) (f)) '((2 . "PURE")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-car! o 3)))) (let ((u (g))) (car o))))))) (f)) '((2 . "PURE") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-cdr! o 3)))) (let ((u (g))) (car o))))))) (f)) '((2 . "PURE") (11 . "PROC")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (set-car! o 3))) (f)))))) (f)) '((2 . "PURE")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-car! o 3)))) (let ((u (g))) (let ((v (car o))) (f)))))))) (f)) '((2 . "PURE") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((o (cons 1 2))) o)))) (let ((p (g))) (car p)))))) (f)) '((2 . "PURE") (5 . "PURE")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((o (cons 1 2))) o)))) (let ((p (g))) p))))) (f)) '((2 . "PURE") (5 . "PURE")))
  (test '(let ((g (lambda (p) (set-cdr! p 3)))) (let ((f (lambda () (let ((o (cons 1 2))) (let ((u (g o))) (cdr o)))))) (f))) '((2 . "PROC") (10 . "PURE"))) 
  (test '(let ((g (lambda (p) (set-cdr! p 3)))) (letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (g o))) (let ((v (cdr o))) (f))))))) (f))) '((2 . "PROC") (10 . "PURE"))) 
  (test '(let ((o (cons 1 2))) (let ((f (lambda (p) p))) (f o))) '((8 . "PURE")))
  (test '(let ((g (lambda () (cons 1 2)))) (let ((f (lambda () (g)))) (f))) '((2 . "PURE") (9 . "PURE")))
  (test '(let ((g (lambda () (cons 1 2)))) (let ((f (lambda (h) (let ((o (h))) (car o))))) (f g))) '((2 . "PURE") (9 . "PURE")))
  (test '(let ((g (lambda (p) (set-cdr! p 3) ))) (let ((f (lambda (h) (let ((o (cons 1 2))) (let ((u (h o))) (cdr o)))))) (f g))) '((2 . "PROC") (10 . "PURE")))
  (test '(let ((g (lambda (p) (set-cdr! p 3) ))) (let ((f (lambda (h) (let ((o (cons 1 2))) (let ((u (h o))) (cdr o)))))) (letrec ((l (lambda () (let ((v (f g))) (l))))) (l)))) '((2 . "PROC") (10 . "PURE") (28 . "PURE")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((a 123)) a)))) (g))))) (f)) '((2 . "PURE") (5 . "PURE")))
  (test '(let ((g (lambda () (let ((a 3)) a)))) (let ((f (lambda () (g)))) (f))) '((2 . "PURE") (9 . "PURE")))
  (test '(let ((g (lambda () (let ((a 3)) a)))) (let ((f (lambda (h) (h)))) (f g))) '((2 . "PURE") (9 . "PURE")))
  (test '(let ((g (lambda () (let ((a 3)) a)))) (let ((f (lambda (h) (h)))) (letrec ((l (lambda () (let ((u (f g))) (l))))) (l)))) '((2 . "PURE") (9 . "PURE") (15 . "PURE")))
  (test '(let ((x (cons 2 3))) (let ((o (cons 1 x))) (let ((f (lambda () (let ((ox (cdr o))) (set-car! ox 4))))) (f)))) '((14 . "PROC")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((o (cons 1 2))) (let ((u (cdr o))) (let ((v (set-car! o u))) o)))))) (let ((p (g))) (car p)))))) (f)) '((2 . "PURE") (5 . "PURE")))
  (test '(let ((z #f)) (let ((x #t)) (let ((f (lambda () z))) (let ((u (f))) (let ((v (set! x z))) (f)))))) '((8 . "PURE")))
  (test '(let ((o (cons 1 2))) (let ((f (lambda () (cdr o)))) (let ((u (f))) (let ((v (set-cdr! o 3))) (f))))) '((8 . "OBS")))
  (test '(let ((f (lambda (x) (let ((xx x)) xx)))) (let ((p (f 123))) (f p))) '((2 . "PURE")))
  (test '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((u (g))) (let ((v (set! x 5))) (g)))))))) (f)) '((2 . "PURE") (8 . "OBS")))
  (test '(letrec ((f (lambda (n) (let ((p (- n 1))) (f p))))) (f 123)) '((2 . "PURE")))
  (test '(let ((o (cons 1 2))) (let ((f (lambda () (let ((g (lambda () (set-cdr! o 3)))) (let ((u (g))) (cdr o)))))) (f))) '((8 . "PROC") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda (p) (set-car! p 3)))) (g o)))))) (f)) '((11 . "PROC") (2 . "PURE")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((h (lambda (q) (set-cdr! q 3)))) (let ((g (lambda (p) (h p)))) (g o))))))) (f)) '((2 . "PURE") (11 . "PROC") (19 . "PROC")))
  (test '(let ((f (lambda (p) (let ((u (if p (set-car! p 3) (let ((pp (cons 4 5))) (set! p pp))))) p)))) (let ((o (f #f))) (f o))) '((2 . "PROC")))
  (test '(let ((f (lambda () (let ((x 10)) (let ((g (lambda () x))) (let ((u x)) (let ((v (g))) (let ((w (set! x 11))) (g))))))))) (f)) '((2 . "PURE") (8 . "OBS")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (car o)))) (let ((u (car o))) (let ((v (g))) (let ((w (set-car! o 3))) (g))))))))) (f)) '((2 . "PURE") (11 . "OBS")))
  (test treenode1 '((2 . "PURE") (19 . "PURE")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (set-car! o 3))) (f)))))) (f)) '((2 . "PURE")))
  (test '(letrec ((f (lambda (p) (let ((pp (cons 1 2))) (let ((u (set-car! pp p))) (f pp)))))) (f 3)) '((2 . "PURE")))
  (test '(letrec ((f (lambda (p) (let ((o (cons 1 p))) (let ((u (set-car! o 3))) (f o)))))) (f 2)) '((2 . "PURE")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (set-car! o 3))) (let ((v (f))) o)))))) (f)) '((2 . "PURE")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p (cons 1 2))) (let ((u (set-cdr! p 3))) (let ((v (set! p o))) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "PROC")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p (cons 1 2))) (let ((u (set-cdr! p 3))) (let ((p o)) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "PROC")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p o)) (let ((pp (cons 1 2))) (let ((v (set! p pp))) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "PURE")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p o)) (let ((pp (cons 1 2))) (let ((p pp)) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "PURE")))
  (test '(let ((f (lambda () (cons 1 2)))) (f)) '((2 . "PURE")))
  (test '(let ((f (lambda () (cons 1 2)))) (let ((p (f))) (set-car! p 9))) '((2 . "PURE")))
  )


