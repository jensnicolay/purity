#lang racket
(provide (all-defined-out))

(define (add-append e)
  `(letrec ((append (lambda (l1 l2)
                      (let ((_a_t1 (null? l1)))
                        (if _a_t1
                            l2
                            (let ((_a_t2 (car l1)))
                              (let ((_a_t3 (cdr l1)))
                                (let ((_a_t4 (append _a_t3 l2)))
                                  (cons _a_t2 _a_t4)))))))))
     ,e))

(define (add-equal? e)
  `(letrec ((equal? (lambda (x1 x2)
                      (let ((_b_t2 (pair? x1)))
                        (if _b_t2
                            (let ((_b_t3 (pair? x2)))
                              (if _b_t3
                                  (let ((_b_t4 (car x1)))
                                    (let ((_b_t5 (car x2)))
                                      (let ((_b_t6 (equal? _b_t4 _b_t5)))
                                        (if _b_t6
                                            (let ((_b_t7 (cdr x1)))
                                              (let ((_b_t8 (cdr x2)))
                                                (equal? _b_t7 _b_t8)))
                                            #f))))
                                  #f))
                            (eq? x1 x2))))))
     ,e))
;; Free variables: list set-car! set-cdr!
(define (add-cars e)
  `(let ((cadr (lambda (p) (let ((_p0 (cdr p))) (car _p0)))))
     (let ((caar (lambda (p) (let ((_p0 (car p))) (car _p0)))))
       (let ((cddr (lambda (p) (let ((_p0 (cdr p))) (cdr _p0)))))
         (let ((caadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (car _p1))))))
           (let ((cdadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (cdr _p1))))))
             (let ((caddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (car _p1))))))
               (let ((cdddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (cdr _p1))))))
                 (let ((cadddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (let ((_p2 (cdr _p1))) (car _p2)))))))
                   ,e)))))))))

(define (add-map e)
  `(letrec ((map (lambda (f l)
                   (let ((_p0 (pair? l)))
                     (if _p0
                         (let ((_p1 (car l)))
                           (let ((_p2 (f _p1)))
                             (let ((_p3 (cdr l)))
                               (let ((_p4 (map f _p3)))
                                 (cons _p2 _p4)))))
                         '())))))
     ,e))

(define (add-length e)
  `(letrec ((length (lambda (l)
                      (let ((_p0 (null? l)))
                        (if _p0
                            0
                            (let ((_p1 (cdr l)))
                              (let ((_p2 (length _p1)))
                                (+ 1 _p2))))))))
     ,e))

(define (add-reverse e)
  `(let ((reverse (lambda (l)
                   (letrec ((reverse-acc (lambda (l acc)
                                           (let ((c (null? l)))
                                             (if c
                                                 acc
                                                 (let ((u (cdr l)))
                                                   (let ((v (car l)))
                                                     (let ((w (cons v acc)))
                                                       (reverse-acc u w)))))))))
                     (reverse-acc l '())))))
    ,e))

(define (add-list? e)
  `(letrec ((list? (lambda (l)
                     (let ((u (null? l)))
                       (if u
                           #t
                           (let ((v (pair? l)))
                             (if v
                                 (let ((w (cdr l)))
                                   (list? w))
                                 #f)))))))
     ,e))

(define (add-assoc e)
  `(letrec ((assoc (lambda (x l)
                     (let ((c (null? l)))
                       (if c
                           #f
                           (let ((binding (car l)))
                             (let ((key (car binding)))
                               (let ((m (equal? key x)))
                                 (if m
                                     binding
                                     (let ((rest (cdr l)))
                                       (assoc x rest)))))))))))
    ,e))



;(define p1 '(let ((c (cons 1 #f))) (car c)))
;(define p2 '(let ((c (cons 1 #f))) (cdr c)))
;(define p3 '(let ((u '(1 2 3))) (let ((v (cdr u))) (car v))))
;(define p4 '(let ((x '(1 (2 3)))) (let ((y (cdr x))) (let ((z (car y))) (car z)))))
;(define p5 (add-equal? '(let ((x '(1    "ho"))) (let ((y '(1 #f "ho"))) (equal? x y)))))
;(define p6 (add-reverse '(let ((x '(1 #f "ho"))) (let ((y (reverse x))) (car y)))))
;(define p7 (add-reverse '(let ((xx (cons 2 '()))) (let ((x (cons 1 xx))) (let ((y (reverse x))) (car y))))))
;(define p8 (add-equal? '(equal? 1 2)))
;(define p9 (add-equal? '(equal? 1 1)))
;(define p10 (add-equal? '(let ((xx (cons 2 '()))) (let ((x (cons 1 xx))) (let ((y '(1 2))) (equal? x y))))))
;(define p11 (add-append '(let ((x '(1))) (let ((y '(2))) (let ((z (append x y))) (~a z))))))
;(define p12 (add-append '(let ((x '(1))) (let ((y '(2 3))) (let ((z (append x y))) (let ((u (cdr z))) (let ((v (car u))) v)))))))
;(define p13 '(let ((x '(1 2 3))) (~a x)))
;(define p14 (add-append '(let ((x '(1 2 3))) (let ((y '(4 5))) (append x y)))))
;(define p15 '(let ((z 123)) (let ((f (lambda () z))) (f))))
(define sq '((lambda (x) (* x x)) 8))
(define loopy1 '(letrec ((f (lambda () (f)))) (f)))
(define loopy2 '((lambda (x) (x x)) (lambda (y) (y y))))
(define safeloopy1 '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)))
(define hellomemo '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))))
(define helloset! '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))))
(define hellomemoset! '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))))
(define fac (file->value "test/fac.scm"))
(define fib (file->value "test/fib.scm"))
(define blur (file->value "test/blur.scm"))
(define eta (file->value "test/eta.scm"))
(define gcipd (file->value "test/gcipd.scm"))
(define kcfa2 (file->value "test/kcfa2.scm"))
(define kcfa3 (file->value "test/kcfa3.scm"))
(define loop2 (file->value "test/loop2.scm"))
(define mj09 (file->value "test/mj09.scm"))
(define rotate (file->value "test/rotate.scm"))
(define sat (file->value "test/sat.scm"))
(define rsa (file->value "test/rsa.scm"))
(define factor (add-reverse (file->value "test/factor.scm")))
(define primtest (file->value "test/primtest.scm"))
(define regex (add-equal? (file->value "test/regex.scm")))
(define cpstak (file->value "test/cpstak.scm"))
(define churchnums (file->value "test/churchnums.scm"))
(define nqueens (add-append (file->value "test/nqueens.scm")))
(define fib-mut (file->value "test/fib-mut.scm"))
(define account (file->value "test/account.scm"))
(define collatz (file->value "test/collatz.scm"))
(define scm2java (add-list? (file->value "test/scm2java.scm")))
(define mceval (add-length (add-cars (add-map (file->value "test/mceval.scm")))))
(define mceval2 (add-equal? (add-cars (add-assoc (add-map (file->value "test/mceval2.scm"))))))
(define boyer (add-equal? (add-cars (file->value "test/boyer.scm"))))
(define ack (add-equal? (file->value "test/ack.scm")))
(define dderiv (add-equal? (add-cars (add-map (file->value "test/dderiv.scm")))))
(define takl (add-equal? (file->value "test/takl.scm")))
(define divrec (add-cars (add-equal? (file->value "test/divrec.scm"))))
(define sound1 (file->value "test/sound1.scm"))
(define sound2 (file->value "test/sound2.scm"))
(define sound3 (file->value "test/sound3.scm"))
(define sound4 (file->value "test/sound4.scm"))
(define sound5 (file->value "test/sound5.scm"))
(define sound6 (file->value "test/sound6.scm"))
(define sound7 (file->value "test/sound7.scm"))
(define sound8 (file->value "test/sound8.scm"))
(define treenode1 '(let ((tree-node (lambda (l) (let ((this (cons 1 2))) (let ((a this)) (set-car! a l)))))) 
           (letrec ((f (lambda (levels) (let ((left #f)) (let ((c (<= levels 1))) (let ((u (if c (set! left 'null) (let ((n (- levels 1))) (let ((ll (f n))) (set! left ll)))))) (tree-node left)))))))
             (f 3))))
(define destruct (add-length (file->value "test/destruct.scm")))
(define purity1 '(let ((z #f)) (let ((f (lambda () (let ((g (lambda () (let ((h (lambda () (set! z #t)))) (h))))) (g))))) (f))))
(define purity2 '(let ((f (lambda () (let ((z #f)) (let ((g (lambda () (let ((h (lambda () (set! z #t)))) (h))))) (g)))))) (f)))
(define purity3 '(let ((z #f)) (let ((f (lambda () z))) (let ((u (f))) (let ((v (set! z #t))) (f))))))
(define purity4 '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((u (g))) (let ((v (set! x 5))) (g)))))))) (f)))
(define purity5 '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-car! o 3)))) (let ((u (g))) (car o))))))) (f)))
(define purity6 '(let ((g (lambda (p) (set-cdr! p 3)))) (let ((f (lambda () (let ((o (cons 1 2))) (let ((u (g o))) (cdr o)))))) (f))))
(define purity7 '(let ((g (lambda (p) (set-cdr! p 3) ))) (let ((f (lambda (h) (let ((o (cons 1 2))) (let ((u (h o))) (cdr o)))))) (f g))))
(define purity8 '(let ((o (cons 1 2))) (let ((f (lambda () (cdr o)))) (let ((u (f))) (let ((v (set-cdr! o 3))) (f))))))
(define purity9 '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((u (g))) (let ((v (set! x 5))) (g)))))))) (f)))
(define purity10 '(let ((o (cons 1 2))) (let ((f (lambda () (let ((g (lambda () (set-cdr! o 3)))) (let ((u (g))) (cdr o)))))) (f))))
(define purity11 '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda (p) (set-car! p 3)))) (g o)))))) (f)))
(define purity12 '(let ((f (lambda () (let ((x 10)) (let ((g (lambda () x))) (let ((u x)) (let ((v (g))) (let ((w (set! x 11))) (g))))))))) (f)))
(define purity13 '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (car o)))) (let ((u (car o))) (let ((v (g))) (let ((w (set-car! o 3))) (g))))))))) (f)))
(define purity14 '(letrec ((f (lambda (n) (let ((c (zero? n))) (if c 'done (let ((z #f)) (let ((g (lambda () (let ((u (set! z #t))) (let ((nn (- n 1))) (f nn)))))) (g)))))))) (f 4)))
(define purity15 '(letrec ((f (lambda (n) (let ((c (zero? n))) (if c 'done (let ((o (cons 1 2))) (let ((g (lambda () (set-car! o 3)))) (let ((u (g))) (let ((v (car o))) (let ((nn (- n 1))) (f nn))))))))))) (f 4)))
(define purity16 '(let ((o (cons 1 2))) (letrec ((f (lambda (n) (let ((c (zero? n))) (if c 'done (let ((p (cons 1 2))) (let ((u (set-cdr! p 3))) (let ((v (set! p o))) (let ((w (set-cdr! p 4))) (let ((nn (- n 1))) (f nn))))))))))) (f 4))))
(define purity17 '(let ((o (cons 1 2))) (letrec ((f (lambda (n) (let ((c (zero? n))) (if c 'done (let ((p o)) (let ((pp (cons 1 2))) (let ((v (set! p pp))) (let ((w (set-cdr! p 4))) (let ((nn (- n 1))) (f nn))))))))))) (f 4))))
(define purity18 '(let ((g (lambda (p) (set-cdr! p 3) ))) (let ((f (lambda (h) (let ((o (cons 1 2))) (let ((u (h o))) (cdr o)))))) (letrec ((l (lambda (n) (let ((c (zero? n))) (if c 'done (let ((v (f g))) (let ((nn (- n 1))) (l nn)))))))) (l 4)))))

(define fresh1 '(let ((z (cons 1 2))) (let ((f (lambda () (let ((o (cons 3 4))) (let ((g (lambda () (set! o z)))) (let ((u (g))) (set-car! o 5))))))) (f))))
