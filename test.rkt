#lang racket
(provide (all-defined-out))

(define (add-append e)
  `(letrec ((append (lambda (l1 l2)
                      (let ((_a_t1 (null? l1)))
                        (if _a_t1
                            l2
                            (let ((_a_t2 (car l1)))
                              (let ((_a_t3 (cdr l1)))
                                (let ((_a_t4 (append _a_t3 l2)))
                                  (cons _a_t2 _a_t4)))))))))
     ,e))

(define (add-equal? e)
  `(letrec ((equal? (lambda (x1 x2)
                      (let ((_b_t2 (pair? x1)))
                        (if _b_t2
                            (let ((_b_t3 (pair? x2)))
                              (if _b_t3
                                  (let ((_b_t4 (car x1)))
                                    (let ((_b_t5 (car x2)))
                                      (let ((_b_t6 (equal? _b_t4 _b_t5)))
                                        (if _b_t6
                                            (let ((_b_t7 (cdr x1)))
                                              (let ((_b_t8 (cdr x2)))
                                                (equal? _b_t7 _b_t8)))
                                            #f))))
                                  #f))
                            (eq? x1 x2))))))
     ,e))
;; Free variables: list set-car! set-cdr!
(define (add-cars e)
  `(let ((cadr (lambda (p) (let ((_p0 (cdr p))) (car _p0)))))
     (let ((caar (lambda (p) (let ((_p0 (car p))) (car _p0)))))
       (let ((cddr (lambda (p) (let ((_p0 (cdr p))) (cdr _p0)))))
         (let ((caadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (car _p1))))))
           (let ((cdadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (cdr _p1))))))
             (let ((caddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (car _p1))))))
               (let ((cdddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (cdr _p1))))))
                 (let ((cadddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (let ((_p2 (cdr _p1))) (car _p2)))))))
                   ,e)))))))))

(define (add-map e)
  `(letrec ((map (lambda (f l)
                   (let ((_p0 (pair? l)))
                     (if _p0
                         (let ((_p1 (car l)))
                           (let ((_p2 (f _p1)))
                             (let ((_p3 (cdr l)))
                               (let ((_p4 (map f _p3)))
                                 (cons _p2 _p4)))))
                         '())))))
     ,e))

(define (add-length e)
  `(letrec ((length (lambda (l)
                      (let ((_p0 (null? l)))
                        (if _p0
                            0
                            (let ((_p1 (cdr l)))
                              (let ((_p2 (length _p1)))
                                (+ 1 _p2))))))))
     ,e))

(define (add-reverse e)
  `(let ((reverse (lambda (l)
                   (letrec ((reverse-acc (lambda (l acc)
                                           (let ((c (null? l)))
                                             (if c
                                                 acc
                                                 (let ((u (cdr l)))
                                                   (let ((v (car l)))
                                                     (let ((w (cons v acc)))
                                                       (reverse-acc u w)))))))))
                     (reverse-acc l '())))))
    ,e))

(define (add-list? e)
  `(letrec ((list? (lambda (l)
                     (let ((u (null? l)))
                       (if u
                           #t
                           (let ((v (pair? l)))
                             (if v
                                 (let ((w (cdr l)))
                                   (list? w))
                                 #f)))))))
     ,e))

(define (add-assoc e)
  `(letrec ((assoc (lambda (x l)
                     (let ((c (null? l)))
                       (if c
                           #f
                           (let ((binding (car l)))
                             (let ((key (car binding)))
                               (let ((m (equal? key x)))
                                 (if m
                                     binding
                                     (let ((rest (cdr l)))
                                       (assoc x rest)))))))))))
    ,e))

(define sq '((lambda (x) (* x x)) 8))
(define loopy1 '(letrec ((f (lambda () (f)))) (f)))
(define loopy2 '((lambda (x) (x x)) (lambda (y) (y y))))
(define safeloopy1 '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)))
(define hellomemo '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))))
(define helloset! '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))))
(define hellomemoset! '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))))
(define fac (file->value "test/fac.scm"))
(define fib (file->value "test/fib.scm"))
(define blur (file->value "test/blur.scm"))
(define eta (file->value "test/eta.scm"))
(define gcipd (file->value "test/gcipd.scm"))
(define kcfa2 (file->value "test/kcfa2.scm"))
(define kcfa3 (file->value "test/kcfa3.scm"))
(define loop2 (file->value "test/loop2.scm"))
(define mj09 (file->value "test/mj09.scm"))
(define rotate (file->value "test/rotate.scm"))
(define sat (file->value "test/sat.scm"))
(define rsa (file->value "test/rsa.scm"))
(define factor (add-reverse (file->value "test/factor.scm")))
(define primtest (file->value "test/primtest.scm"))
(define regex (add-equal? (file->value "test/regex.scm")))
(define cpstak (file->value "test/cpstak.scm"))
(define churchnums (file->value "test/churchnums.scm"))
(define nqueens (add-append (file->value "test/nqueens.scm")))
(define fib-mut (file->value "test/fib-mut.scm"))
(define account (file->value "test/account.scm"))
(define collatz (file->value "test/collatz.scm"))
(define scm2java (add-length (add-list? (file->value "test/scm2java.scm"))))
(define mceval (add-length (add-cars (add-map (file->value "test/mceval.scm")))))
(define mceval2 (add-equal? (add-cars (add-assoc (add-map (file->value "test/mceval2.scm"))))))
(define boyer (add-equal? (add-cars (file->value "test/boyer.scm"))))
(define ack (add-equal? (file->value "test/ack.scm")))
(define dderiv (add-equal? (add-cars (add-map (file->value "test/dderiv.scm")))))
(define takl (add-equal? (file->value "test/takl.scm")))
(define divrec (add-cars (add-equal? (file->value "test/divrec.scm"))))
(define treeadd1 (file->value "test/treeadd1.scm"))
(define treeadd2 (file->value "test/treeadd2.scm"))
(define treeadd3 (file->value "test/treeadd3.scm"))
(define treeadd (file->value "test/treeadd.scm"))
(define sound1 (file->value "test/sound1.scm"))
(define sound2 (file->value "test/sound2.scm"))
(define sound3 (file->value "test/sound3.scm"))
(define sound4 (file->value "test/sound4.scm"))
(define sound5 (file->value "test/sound5.scm"))
(define sound6 (file->value "test/sound6.scm"))
(define sound7 (file->value "test/sound7.scm"))
(define sound8 (file->value "test/sound8.scm"))
(define treenode1 '(let ((tree-node (lambda (l) (let ((this (cons 1 2))) (let ((a this)) (let ((uu (set-car! a l))) a))))))
           (letrec ((f (lambda (levels) (let ((left #f)) (let ((c (<= levels 1))) (let ((u (if c (set! left 'null) (let ((n (- levels 1))) (let ((ll (f n))) (set! left ll)))))) (tree-node left)))))))
             (f 3))))
(define destruc (add-length (file->value "test/destruct.scm")))
(define grid (add-equal? (file->value "test/grid.scm")))
(define grid1 (add-equal? (file->value "test/grid1.scm")))
(define fannkuch (file->value "test/fannkuch.scm"))
(define matrix (file->value "test/matrix.scm"))
(define spectralnorm (file->value "test/spectralnorm.scm"))
(define sieve (file->value "test/sieve.scm"))
(define mandelbrot (file->value "test/mandelbrot.scm"))
(define partialsums (file->value "test/partialsums.scm"))