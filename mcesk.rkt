#lang racket
(provide (all-defined-out))

(require racket/hash)
(require data/gvector)
(require "general.rkt")
(require "ast.rkt")
(require "lattice.rkt")
(require "test.rkt")


(random-seed 111) ; deterministic random
(define CESK-TIMELIMIT (make-parameter 2)) ; timeout in minutes


(define (index v x)
  (let ((i (vector-member x v)))
    (if i
        i
        (let ((i (add1 (vector-ref v 0))))
          (vector-set! v 0 i)
          (vector-set! v i x)
          i))))
(define frameis (make-vector 1000))
(define (frame->framei frame) (index frameis frame))
(define ctxis (make-vector 1000))
(define (ctx->ctxi ctx) (index ctxis ctx))
(define stateis (make-vector 1000))
(define (state->statei q) (index stateis q))
;(define storeis (make-vector 1000)) TIMESTAMPED IN CESK!!!
;(define (store->storei σ) (index storeis σ))

;; domain helpers
(define (env-lookup ρ x)
  (hash-ref ρ x))
(define (env-addresses ρ)
  (list->set (hash-values ρ)))
(define (store-lookup σ a)
  (hash-ref σ a))
(define (store-⊑ σ1 σ2 ⊑)
  (if (eq? σ1 σ2)
      #t
      (if (< (hash-count σ2) (hash-count σ1))
          #f
          (for/and (((k v) σ1))
            (and (hash-has-key? σ2 k)
                 (⊑ v (hash-ref σ2 k)))))))
(define (stack-lookup Ξ τ)
  (hash-ref Ξ τ))

;; should become API on machine (system)
(define (state-κ s)
  (match s
    ((ev _ _ _ _ κ) κ)
    ((ko _ _ _ κ) κ)))

;(define (state-Ξ s Ξ)
;  (match s
;    ((ev _ _ _ _ _ Ξi) (vector-ref Ξ Ξi))
;    ((ko _ _ _ _ Ξi) (vector-ref Ξ Ξi))))
;;

;; machine
(struct ev (e ρ σ ι κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "EV ~a\nρ ~a\nι ~a\nκ ~a" (ev-e v) (ev-ρ v) (ev-ι v) (ev-κ v))))
(struct ko (v σ ι κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "KO v ~a\nι ~a\nκ ~a" (ko-v v) (ko-ι v) (ko-κ v))))
(struct letk (x e ρ) #:transparent)
(struct letreck (x e ρ) #:transparent)
(struct haltk () #:transparent)
(struct clo (λ ρ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<clo ~a>" («lam»-l (clo-λ v)))))
(struct prim (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                        (equal? (prim-name s1) (prim-name s2))))
                                                   (define hash-proc (lambda (s rhash) (equal-hash-code (prim-name s))))
                                                   (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim-name s))))))
(struct addr (a) #:transparent)

(struct ctx (e λ ρ* clo args σi) #:transparent)
(struct transition (s E) #:transparent)

(struct wv (a x) #:transparent)
(struct rv (a x) #:transparent)
(struct wp (a n x) #:transparent)
(struct rp (a n x) #:transparent)
;(struct al (a) #:transparent)

(struct system (states duration initial graph state-σ Ξ lattice answer? memo-count exit msg) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<sys #~a memo ~a ~a ~a>" (vector-length (system-states v)) (system-memo-count v) (system-exit v) (~a (system-msg v) #:max-width 70))))

(define (touches d)
  (if (set? d)
      (for/fold ((as (set))) ((v d)) (set-union as (touches v)))
      (match d
        ((clo _ ρ) (env-addresses ρ))
        ((letk _ _ ρ) (env-addresses ρ))
        ((letreck _ _ ρ) (env-addresses ρ))
        ((addr a) (set a))
        ((cons x y) (set-union (touches x) (touches y)))
        (_ (set)))))
(define (reachable A σ γ)
  (let loop ((A A) (R (set)))
    (if (set-empty? A)
        R
        (let ((a (set-first A)))
          (if (set-member? R a)
              (loop (set-rest A) R)
              (let* ((v (γ (store-lookup σ a)))
                     (T (touches v)))
                (loop (set-union (set-rest A) T) (set-add R a))))))))
(define (s-referenced s Ξ)
  (match s
    ((ev e ρ _ ι κ) (set-union (env-addresses (↓ ρ (free e))) (stack-addresses ι κ Ξ)))
    ((ko v _ ι κ) (stack-addresses ι κ Ξ))))
  
;(define (gc s Ξ γ ctx-A)
;  (match s
;    ((ev e ρ σ ι κ)
;     (let* ((ρ* (↓ ρ (free e)))
 ;           (R (reachable (set-union (env-addresses ρ*) (stack-addresses ι κ ctx-A)) σ γ))
;            (σ* (↓ σ R)))
;       (ev e ρ* σ* ι κ)))
;    ((ko ι κ v σ)
;     (let* ((R (reachable (set-union (touches v) (stack-addresses ι κ ctx-A)) σ γ))
;            (σ* (↓ σ R)))
;       (ko ι κ v σ*)))))
(define (stack-frames ι κ Ξ)
  (let loop ((todo (set (cons ι κ))) (result (set)) (seen (set)))
    (if (set-empty? todo)
        result
        (match-let (((cons ι κ) (set-first todo)))
          (let* ((result* (set-union result (list->set ι))))
            (if (or (not κ) (set-member? seen κ))
                (loop (set-rest todo) result* seen)
                (let ((ικs (stack-lookup Ξ κ)))
                  (loop (set-union (set-rest todo) ικs) result* (set-add seen κ)))))))))
(define (stack-pop ι κ Ξ G)
  (if (null? ι)
      (if (set-member? G κ)
          (set)
          (let ((ικs (stack-lookup Ξ κ)))
            (apply set-union (set-map ικs (lambda (ικ) (stack-pop (car ικ) (cdr ικ) Ξ (set-add G κ)))))))
      (set (list ι κ G)))) 
(define (stack-contexts κ Ξ)
  (let loop ((todo (set (cons #f κ))) (seen (set)))
    (if (set-empty? todo)
        seen
        (let ((κ (cdr (set-first todo))))
          (if (or (not κ) (set-member? seen κ))
              (loop (set-rest todo) seen)
              (loop (set-union (set-rest todo) (stack-lookup Ξ κ)) (set-add seen κ)))))))
(define (stack-addresses ι κ Ξ)
  (for/fold ((A (set))) ((φ (stack-frames ι κ Ξ)))
    (set-union A (touches φ))))

(define (make-machine lattice alloc kalloc monotonic-store memo)

  (define α (lattice-α lattice))
  (define γ (lattice-γ lattice))
  (define ⊥ (lattice-⊥ lattice))
  (define ⊑ (lattice-⊑ lattice))
  (define ⊔ (lattice-⊔ lattice))
  (define true? (lattice-true? lattice))
  (define false? (lattice-false? lattice))
  (define α-eq? (lattice-eq? lattice))

  
  (define (explore e)
    (define σ (hash))
    (define σi 0)
    (define stores (make-gvector))
    (define Ξ (hash))
    (define Ξi 0)
    ;(define stack-stores '())
    (define M (hash))
    (define R (hash))
    (define U (hash))
    (define memo-edges (mutable-set))

    (define state-store (if monotonic-store
                            (lambda ()
                              #f)
                            (lambda ()
                              σi)))

    
    (include "primitives.rkt")
    
    (define (inject e)
      (let ((global* (append (lattice-global lattice) ; all fresh (freshness analysis supposes this: UNWANTED DEP!)
                             `(("eq?" . ,(α (prim "eq?" prim-eq?)))
                               ("~a" . ,(α (prim "~a" prim-to-string)))
                               ("error" . ,(α (prim "error" prim-error)))
                               ("pair?" . ,(α (prim "pair?" prim-pair)))
                               ("vector-length" . ,(α (prim "vector-length" prim-vector-length)))
                               ("vector-copy" . ,(α (prim "vector-copy" prim-vector-copy)))
                               )))
            (compiled-e (compile e)))
        (set! conc-alloc-counter 0)
        (let loop ((global global*) (ρ (hash)))
          (match global
            ('()
             (let* ((ρ* (↓ ρ (free compiled-e)))
                    (R (reachable (env-addresses ρ*) σ γ))
                    (σ* (↓ σ R)))
               (set! σ σ*)
               (set! stores (make-gvector #:capacity 4096))
               (gvector-add! stores σ)
               ;(set! stack-stores (list Ξ))
               (ev compiled-e ρ* (state-store) `(,(haltk)) #f)))
            ((cons (cons x v) r)
             (let ((a (conc-alloc)))
               (set! σ (hash-set σ a v))
               (loop r (hash-set ρ x a))))))))
    
    ;(define (stack-to-string stack)
    ;  (cons (map frame->framei (car stack)) (ctx->ctxi (cdr stack))))
    
    (define (env-bind ρ x a)
      (hash-set ρ x a))
    
    (define (store-alloc! a v)
      (if (hash-has-key? σ a) 
          (let* ((current (hash-ref σ a ⊥))
                 (updated (⊔ current v)))
            (unless (equal? current updated)
              (set! σ (hash-set σ a updated))
              (gvector-add! stores σ)
              (set! σi (add1 σi))))
          (begin
            (set! σ (hash-set σ a v))
            (gvector-add! stores σ)
            (set! σi (add1 σi)))))
          
    (define (store-update! a v)
      (let* ((current (hash-ref σ a))
             (updated (⊔ current v)))
        (unless (equal? current updated)
          (set! σ (hash-set σ a updated))
          (gvector-add! stores σ)
          (set! σi (add1 σi)))))
      
    (define (stack-alloc! κ stack)
      ;(printf "allocing ctx ~a stack ~a " (ctx->ctxi τ) (stack-to-string stack))
      (let ((stacks (hash-ref Ξ κ #f)))
        (if stacks
            (unless (set-member? stacks stack)
              ;(printf "ADDING to ~a\n" (set-map stacks stack-to-string))
              (set! Ξ (hash-set Ξ κ (set-add stacks stack)))
              ;(for ((s (hash-ref pops κ (set))))
              ;  (match s
              ;    ((ko v _ _ _)
              ;     (let ((s* (ko v (state-store) (car stack) (cdr stack))))
              ;       (hash-set! graph s (set-add (hash-ref graph s (set)) (transition s* (set))))
                     ;(printf "adding ~a -> ~a\n" (state->statei s) (state->statei s*))
              ;       (set-remove! visited s*)
              ;       (set! todo (set-add todo s*))))))
              ;(set! stack-stores (cons Ξ stack-stores))
              (set! Ξi (add1 Ξi))
              )
            (begin 
              (set! Ξ (hash-set Ξ κ (set stack)))
              ;(set! stack-stores (cons Ξ stack-stores))
              (set! Ξi (add1 Ξi))
            ))))
    
    (define (alloc-literal! e)
      (if (pair? e)
          (let ((car-v (alloc-literal! (car e))))
            (let ((cdr-v (alloc-literal! (cdr e))))
              (let ((a (alloc e e)))
                (store-alloc! a (α (cons car-v cdr-v)))
                (α (addr a)))))
          (α e)))
    
    (define (eval-atom ae ρ)
      (match ae
        ((«lit» _ v)
         (values (α v) (set)))
        ((«id» _ x)
         (let ((a (env-lookup ρ x)))
           (values (store-lookup σ a) (set (rv a ae)))))
        ((«lam» _ x e)
         (let ((cl (clo ae ρ)))
           (values (α cl) (set))))
        ((«quo» _ atom)
         (values (α atom) (set)))
        (_ (error "cannot handle ae" ae))))
    
    (define (apply-let-kont x e ρ ι κ v E)
      (let* ((a (alloc x κ))
             (ρ* (env-bind ρ («id»-x x) a)))
        (store-alloc! a v)
        (set (transition (ev e ρ* (state-store) ι κ) E))))
    (define (apply-letrec-kont x e ρ ι κ v E)
      (let* ((a (env-lookup ρ («id»-x x))))
        (store-update! a v)
        (set (transition (ev e ρ (state-store) ι κ) E))))
    (define (apply-local-kont ι κ v E)
      (match ι
        ((cons (letk x e ρ) ι)
         (apply-let-kont x e ρ ι κ v E))
        ((cons (letreck x e ρ) ι)
         (apply-letrec-kont x e ρ ι κ v E))
        (_ (set (transition (ko v (state-store) ι κ) E)))))
    
    (define (print-state q)
      (match q
        ((ev e ρ σ ι κ) (printf "EV ~a\nρ ~a σ ~a\nι ~a κ ~a frames ~a\n" (~a e #:max-width 40) ρ "σ" (map frame->framei ι) (ctx->ctxi κ) (set-map (stack-frames ι κ Ξ) frame->framei)))
        ((ko v σ ι κ) (printf "KO ~a σ ~a\nι ~a κ ~a frames ~a\n" v "σ" (map frame->framei ι) (ctx->ctxi κ) (set-map (stack-frames ι κ Ξ) frame->framei)))))
    
    (define (step q)
      ;(printf "exploring ~a\n" (state->statei q))
      ;(print-state q)
      ;(read)
      (match q
        ((ev (? ae? ae) ρ _ ι κ)
         (let-values (((v E) (eval-atom ae ρ)))
           (set (transition (ko v (state-store) ι κ) E))))
        ((ev («if» _ ae e1 e2) ρ _ ι κ)
         (let-values (((v E) (eval-atom ae ρ)))
           (set-union (if (true? v)
                          (if #f;(ae? e1)
                              (let-values (((v* E*) (eval-atom e1 ρ)))
                                (set (transition (ko v* (state-store) ι κ) (set-union E E*))))
                              (set (transition (ev e1 ρ (state-store) ι κ) E)))
                          (set))
                      (if (false? v)
                          (if #f;(ae? e2)
                              (let-values (((v* E*) (eval-atom e2 ρ)))
                                (set (transition (ko v* (state-store) ι κ) (set-union E E*))))
                              (set (transition (ev e2 ρ (state-store) ι κ) E)))
                          (set)))))
        ((ev («let» _ x e0 e1) ρ _ ι κ)
         (if (ae? e0)
             (let-values  (((v E) (eval-atom e0 ρ)))
               (apply-let-kont x e1 ρ ι κ v E))
             (set (transition (ev e0 ρ (state-store) (cons (letk x e1 ρ) ι) κ) (set)))))
        ((ev («letrec» _ x e0 e1) ρ _ ι κ)
         (let* ((a (alloc x κ))
                (ρ* (env-bind ρ («id»-x x) a)))
           (store-alloc! a ⊥)
           (if (ae? e0)
               (let-values (((v E) (eval-atom e0 ρ*)))
                 (apply-letrec-kont x e1 ρ* ι κ v E))
               (set (transition (ev e0 ρ* (state-store) (cons (letreck x e1 ρ*) ι) κ) (set))))))
        ((ev («set!» _ x ae) ρ _ ι κ)
         (let-values (((v E) (eval-atom ae ρ)))
           (let* ((a (env-lookup ρ («id»-x x))))
             (store-update! a v)
             (set (transition (ko (α 'undefined) (state-store) ι κ) (set-add E (wv a x)))))))
        ((ev («quo» _ e) ρ _ ι κ)
         (let ((v (alloc-literal! e)))
           (set (transition (ko v (state-store) ι κ) (set)))))
        ((ev («car» _ x) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom x ρ)))
           (let-values (((v E) (for/fold ((v ⊥) (E (set))) ((w (γ v1)))
                                 (match w
                                   ((addr a)
                                    (values (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                                              (match ww
                                                ((cons v-car _) (⊔ v v-car))
                                                (_ v)))
                                            (set-add E (rp a "car" x))))
                                   (_ (values v E))))))
             (set (transition (ko v (state-store) ι κ) (set-union E1 E))))))
        ((ev («cdr» _ x) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom x ρ)))
           (let-values (((v E) (for/fold ((v ⊥) (E (set))) ((w (γ v1)))
                                 (match w
                                   ((addr a)
                                    (values (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                                              (match ww
                                                ((cons _ v-cdr) (⊔ v v-cdr))
                                                (_ v)))
                                            (set-add E (rp a "cdr" x))))
                                   (_ (values v E))))))
             (set (transition (ko v (state-store) ι κ) (set-union E1 E))))))
        ((ev («set-car!» _ x ae) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom x ρ))
                      ((v2 E2) (eval-atom ae ρ)))
           (let ((E (for/fold ((E (set))) ((w (γ v1)))
                      (match w
                        ((addr a)
                         (for/fold ((E E)) ((ww (γ (store-lookup σ a))))
                           (match ww
                             ((cons _ v-cdr)
                              (store-update! a (α (cons v2 v-cdr)))
                              (set-add E (wp a "car" x)))
                             (_ E))))
                        (_ E)))))
             (if (set-empty? E) (set) (set (transition (ko (α 'undefined) (state-store) ι κ) (set-union E1 E2 E)))))))
        ((ev («set-cdr!» _ x ae) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom x ρ))
                      ((v2 E2) (eval-atom ae ρ)))
           (let ((E (for/fold ((E (set))) ((w (γ v1)))
                      (match w
                        ((addr a)
                         (for/fold ((E E)) ((ww (γ (store-lookup σ a))))
                           (match ww
                             ((cons v-car _)
                              (store-update! a (α (cons v-car v2)))
                              (set-add E (wp a "cdr" x)))
                             (_ E))))
                        (_ E)))))
             (if (set-empty? E) (set) (set (transition (ko (α 'undefined) (state-store) ι κ) (set-union E1 E2 E)))))))
        ((ev (and («cons» _ ae1 ae2) e) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom ae1 ρ))
                      ((v2 E2) (eval-atom ae2 ρ)))
           (let* ((a (alloc e e))
                  (v (α (cons v1 v2))))
             (store-alloc! a v)
             (set (transition (ko (α (addr a)) (state-store) ι κ) (set-union E1 E2))))))
        ((ev («vector-ref» _ x ae) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom x ρ)))
           (let-values (((v2 E2) (eval-atom ae ρ)))
             (let ((index v2))
               (let-values (((v E) (for/fold ((v ⊥) (E (set))) ((w (γ v1)))
                                     (match w
                                       ((addr a)
                                        (values (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                                                  (if (hash? ww)
                                                      (for/fold ((v v)) (((key val) ww))
                                                        (if (or (⊑ index key) (⊑ key index) )
                                                            (⊔ v val)
                                                            v))
                                                      v))
                                                (set-add E (rp a v2 x)))) ; TODO v2 or the actually read keys?
                                       (_ (values v E))))))
                   (set (transition (ko v (state-store) ι κ) (set-union E1 E2 E))))))))
        ((ev («vector-set!» _ x ae1 ae2) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom x ρ)))
           (let-values (((v2 E2) (eval-atom ae1 ρ)))
             (let-values (((v3 E3) (eval-atom ae2 ρ)))
               (let ((E (for/fold ((E (set))) ((w (γ v1)))
                          (match w
                            ((addr a)
                             (for/fold ((E E)) ((ww (γ (store-lookup σ a))))
                               (if (hash? ww)
                                   (begin
                                     (store-update! a (α (hash-set ww v2 (⊔ (hash-ref ww v2 ⊥) v3))))
                                     (set-add E (wp a v2 x)))
                                   E)))
                            (_ E)))))
                 (if (set-empty? E) (set) (set (transition (ko (α 'undefined) (state-store) ι κ) (set-union E1 E2 E3 E)))))))))
        ((ev (and («make-vector» _ ae1 ae2) e) ρ _ ι κ)
         (let-values (((v1 E1) (eval-atom ae1 ρ)))
           (let-values (((v2 E2) (eval-atom ae2 ρ)))
             (let* ((a (alloc e e))
                    (num v1)
                    (global (lattice-global lattice))
                    (lt-proc (lambda (x y)
                               (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "<" global)))))
                                 (⊔ result ((prim2-proc prim2) x y)))))
                    (add-proc (lambda (x y)
                                (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "+" global)))))
                                  (⊔ result ((prim2-proc prim2) x y)))))
                    (init v2)
                    (h (hash)))
               (let loop ((h h) (i (α 0)))
                 (if (and (true? (lt-proc i num)) (not (hash-has-key? h i)))
                     (loop (hash-set h i init) (add-proc i (α 1)))
                     (let ((v (α h)))
                       (store-alloc! a v)
                       (set (transition (ko (α (addr a)) (state-store) ι κ) (set-union E1 E2))))))))))
        ((ev (and («app» _ rator rands) e) ρ _ ι κ)
         (let-values (((v E) (eval-atom rator ρ)))
           (let rands-loop ((rands rands) (rvs '()) (E E))
             (if (null? rands)
                 (for/fold ((succ (set))) ((w (γ v)))
                   (match w
                     ((clo (and λ («lam» _ x e0)) ρ**)
                      (let ((σi-caller (state-store)))
                        (define (bind-loop x vs ρ*)
                          (match x
                            ('()
                             (if memo
                                 (let* ((inv (cons w vs))
                                        (m (hash-ref M inv #f)))
                                   (if (pair? m)
                                       (let* ((Ar (hash-ref R inv (set)))
                                              (σm* (↓ σ Ar))
                                              (σm (car m)))
                                         (if (equal? σm* σm)
                                             (let* ((cached (cdr m))
                                                    (s* (ko cached (state-store) ι κ)))
                                               (set-add! memo-edges (cons q s*))
                                               (set! U (hash-set U inv (set-add (hash-ref U inv (set)) q)))
                                               (set-add succ (transition s* (set #|addresses read|#))))
                                             (let ((κ* (kalloc e λ ρ* w vs σi-caller)))
                                               (stack-alloc! κ* (cons ι κ))
                                               (set-add succ (transition (ev e0 ρ* (state-store) '() κ* ) E)))))
                                       (let ((κ* (kalloc e λ ρ* w vs σi-caller)))
                                         (stack-alloc! κ* (cons ι κ))
                                         (set-add succ (transition (ev e0 ρ* (state-store) '() κ* ) E)))))
                                 (let ((κ* (kalloc e λ ρ* w vs σi-caller)))
                                   (stack-alloc! κ* (cons ι κ))
                                   (set-add succ (transition (ev e0 ρ* (state-store) '() κ* ) E)))))
                            ((cons x xs)
                             (if (null? vs)
                                 (set)
                                 (let ((a (alloc x e)))
                                   (store-alloc! a (car vs))
                                   (bind-loop xs (cdr vs) (env-bind ρ* («id»-x x) a)))))))                        
                        (bind-loop x (reverse rvs) ρ**)))
                     ((prim name proc)
                      (set-union succ (list->set (set-map (proc e (reverse rvs) ι κ Ξ) (lambda (vE) (transition (ko (car vE) (state-store) ι κ) (set-union E (cadr vE))))))))
                     ((prim2 _ proc)
                      (set-union succ (set (transition (ko (apply proc (reverse rvs)) (state-store) ι κ) E))))
                     (_ succ)))
                 (let-values (((v E*) (eval-atom (car rands) ρ)))
                   (rands-loop (cdr rands) (cons v rvs) (set-union E E*)))))))
        ((ko _ _ (cons (haltk) _) #f)
         (set))
        ((ko d _ ι κ)
         (if (eq? d ⊥)
             (set)
             (let* ((ικGs (stack-pop ι κ Ξ (set))))
               (for/fold ((succ (set))) ((ικG (in-set ικGs)))
                 (let* ((ι (car ικG))
                        (κ (cadr ικG))
                        (G (caddr ικG))
                        (succ* (apply-local-kont ι κ d (set))))
                   ;(for ((κ G))
                   ;  (hash-set! pops κ (set-add (hash-ref pops κ (set)) q)))
                   (when memo
                     (handle-return! d σ G))
                   (set-union succ succ*))))))
        )) ; end step
    
    (define visited (mutable-set))
    (define graph (make-hash))
    (define states (mutable-set))
    (define initial (inject e))
    (define todo (set initial))

    (define state-σ
      (lambda (σi)
        (if σi
            (gvector-ref stores σi)
            σ)))
    
    (define (make-system duration exit msg)
      (system (list->vector (set->list states)) duration initial graph state-σ Ξ lattice answer? (set-count memo-edges) exit msg))


    (define IMPURE "IMPURE")

;    (define redo-writevi 0)
;    (define redo-writefi 0)
;    (define redo-returni 0)
;    (define redoi 0)
;    (define (redo! I reason)
;      (let ((redo (for/fold ((S (set))) ((inv I))
;                    (set-union S (hash-ref U inv (set))))))
;        (set! redoi (+ redoi (set-count redo)))
;        (cond ((= reason 1) (set! redo-writevi (+ redo-writevi (set-count redo))))
;              ((= reason 2) (set! redo-writefi (+ redo-writefi (set-count redo))))
;              ((= reason 3) (set! redo-returni (+ redo-returni (set-count redo)))))
;        ;(when (zero? (modulo redoi 100))
;        ;  (printf "redo ~a wv ~a wf ~a ret ~a\n" redoi redo-writevi redo-writefi redo-returni))
;        (set! todo (set-union todo redo))
;        (set-subtract! visited redo)))
    
    (define (handle-effect! s eff)
      (match eff
        ((wv a x)
         (handle-write! a s))
        ((wp a n x)
         (handle-write! a s))
        ((rv a x)
         (handle-read! a s))
        ((rp a n x)
         (handle-read! a s))
        ))

    (define (handle-read! a s)
      (for ((τ (stack-contexts (state-κ s) Ξ)))
           (match-let (((ctx e _ _ clo args σi) τ))
          (let* ((σ (state-σ σi))
                 (A (list->set (hash-keys σ))))
            (when (set-member? A a)
              (let ((inv (cons clo args)))
                (set! R (hash-set R inv (set-add (hash-ref R inv (set)) a)))))))))
                  
    (define (handle-write! a s)
      (for ((τ (stack-contexts (state-κ s) Ξ)))
        (match-let (((ctx e _ _ clo args σi) τ))
          (let* ((σ (state-σ σi))
                 (A (list->set (hash-keys σ))))
            (when (set-member? A a)
              (let* ((inv (cons clo args))
                     (m (hash-ref M inv #f)))
                (if (pair? m)
                    (let ((redo (hash-ref U inv (set))))
                      (printf " IMP ~a " (set-count todo))
                      (set! M (hash-set M inv "IMPURE"))
                      (set! todo (set-union todo redo))
                      (set-subtract! visited redo))
                    (unless m
                      (begin (printf " NEWIMP ~a " (set-count todo)) (set! M (hash-set M inv "IMPURE")))))))))))
                        

    ;(define (memo-clean m σm)
    ;  (for/fold ((m (hash)) (d ⊥)) (((σm* d*) (in-hash m)))
    ;    (if (store-⊑ σm* σm ⊑)
    ;        (values m (⊔ d d*))
    ;        (values (hash-set m σm* d*) d))))
          
    (define (handle-return! d σ G)
      (let ((no-refs? (set-empty? (touches d)))) ; don't leak any addresses, since no GC integration and global tables
        (for ((τ (in-set G)))
          (match-let (((ctx e _ _ clo args σi) τ))
            (let* ((inv (cons clo args))
                   (m (hash-ref M inv #f)))
                  (if (pair? m)
                      (if no-refs?
                          (let* ((Ar (hash-ref R inv (set)))
                                 (σm* (↓ σ Ar))
                                 (σm (car m)))
                            (if (equal? σm* σm)
                                (begin
                                  (printf " EQ T ~a S ~a " (set-count todo) (set-count states))
                                  (set! M (hash-set M inv (cons σm (⊔ (cdr m) d))))
                                  (for ((s (in-set (hash-ref U inv (set)))))
                                       (let ((s* (ko d (state-store) (ev-ι s) (ev-κ s))))
                                         (set-add! memo-edges (cons s s*))
                                         (hash-set! graph s (set-add (hash-ref graph s) (transition s* (set))))
                                         (set! todo (set-add todo s*)))))
                                (if (store-⊑ σm σm* ⊑)
                                    (let ((redo (hash-ref U inv (set))))
                                      (printf " SUBS T ~a R ~a S ~a " (set-count todo) (set-count redo) (set-count states))
                                      (set! M (hash-set M inv (cons σm* (⊔ (cdr m) d))))
                                      (set! todo (set-union todo redo))
                                      (set-subtract! visited redo))
                                    (let ((redo (hash-ref U inv (set))))
                                      (set! M (hash-set M inv "POLY"))
                                      (printf " POLY ~a " (set-count todo))
                                      (set! todo (set-union todo redo))
                                      (set-subtract! visited redo)))))
                          (let ((redo (hash-ref U inv (set))))
                            (set! M (hash-set M inv "REFS"))
                            (printf " REFS ~a " (set-count todo))
                            (set! todo (set-union todo redo))
                            (set-subtract! visited redo)))
                      (unless m
                        (if no-refs?
                            (let* ((Ar (hash-ref R inv (set)))
                                   (σm* (↓ σ Ar)))
                              (printf " NEW ~a " (set-count todo))
                              (set! M (hash-set M inv (cons σm* d))))
                            (begin (printf " NEWREFS ~a " (set-count todo)) (set! M (hash-set M inv "REFS")))))))))))

    ;(define state-limit (STATELIMIT))
    (define time-limit (+ (current-milliseconds) (* (CESK-TIMELIMIT) 60000)))

    (let ((start (current-milliseconds)))
      (let explore-loop ()
        (if (and (zero? (remainder (set-count states) 10000))
                 (> (current-milliseconds) time-limit))
            (make-system (- (current-milliseconds) start) 'user "time out")
            (if (set-empty? todo)
                (make-system (- (current-milliseconds) start) 'ok "")
                (let* ((q (set-first todo)))
                  (set! todo (set-rest todo))
                  (if (set-member? visited q)
                      (explore-loop)
                      (let ()
                        ;(printf "q ~a\n" (state->statei q))
                        (set-add! visited q)
                        (set-add! states q)
                        (let* ((old-ii σi)
                               (old-i Ξi)
                               (ts (step q))
                               (new-states (for/set ((t ts))
                                             ;(printf "-> ~a\n" (state->statei (transition-s t)))
                                                    (match-let (((transition s* E) t))
                                                      (when memo
                                                        (for ((eff E)) (handle-effect! q eff)))
                                                      s*)))
                               (existing (hash-ref graph q (set)))
                               (updated (set-union existing ts)))
                          (hash-set! graph q updated)
                          (set! todo (set-union new-states todo))
                          (when (or (> Ξi old-i) (and monotonic-store (> σi old-ii)))
                            (set-clear! visited))
                          (explore-loop)))))))))
                              
  ) ; end explore  
(define (answer? s)
  (match s
    ((ko _ _ (cons (haltk) _) _) #t)
    (_ #f)))

explore)

(define (answer-set sys)
  (let ((answer? (system-answer? sys)))
    (for/fold ((v (set))) ((s (system-states sys)))
      (if (answer? s)
          (set-add v s)
          v))))

(define (answer-value sys)
  (let* ((lattice (system-lattice sys))
         (⊥ (lattice-⊥ lattice))
         (⊔ (lattice-⊔ lattice)))
    (for/fold ((v ⊥)) ((s (answer-set sys)))
      (⊔ v (ko-v s)))))

;; allocators
(define conc-alloc-counter 0)
(define conc-alloc
  (lambda _
    (set! conc-alloc-counter (add1 conc-alloc-counter))
    conc-alloc-counter))

(define (mono-alloc x _)
  x)

(define (poly-alloc x ctx)
  (cons x (and ctx (ctx-e ctx))))
;;

(define conc-kalloc (lambda (e lam ρ* clo args σi) (ctx (conc-alloc) lam ρ*))); #f #f #f)))
(define free-kalloc (lambda (e lam ρ* clo args σi) (ctx #f lam ρ* #f #f #f))) ; no 1-cfa (no e) TODO!!!!
(define concm-kalloc (lambda (e lam ρ* clo args σi) (ctx e #f #f clo args σi)))
(define aacm-kalloc (lambda (e lam ρ* clo args σi) (ctx e #f #f clo args σi)))

(define conc-mach (make-machine conc-lattice conc-alloc concm-kalloc #f #f))
(define conc-mach-m (make-machine conc-lattice conc-alloc concm-kalloc #f #t))
(define type-mach-0 (make-machine type-lattice mono-alloc aacm-kalloc #t #f))
(define type-mach-0m (make-machine type-lattice mono-alloc aacm-kalloc #t #t))
(define type-mach-1 (make-machine type-lattice poly-alloc aacm-kalloc #t #f))

(define (do-eval e mach)
  (let ((sys (mach e)))
    (if (eq? (system-exit sys) 'ok)
        (answer-value sys)
        (raise (system-msg sys)))))

(define (conc-eval e)
  (do-eval e conc-mach))
(define (conc-eval-m e)
  (do-eval e conc-mach-m))
(define (type-eval-0 e)
  (do-eval e type-mach-0))
(define (type-eval-0m e)
  (do-eval e type-mach-0m))
(define (type-eval-1 e)
  (do-eval e type-mach-1))

(define (state-repr s)
  (match s
    ((ev e ρ _ ι κ) (format "~a | ~a" (~a e #:max-width 20) (ctx->ctxi κ)))
    ((ko v _ ι κ) (format "~a | ~a" (~a v #:max-width 20) (ctx->ctxi κ)))))

(define (generate-dot graph name)  
  (let ((dotf (open-output-file (format "~a.dot" name) #:exists 'replace)))
    (fprintf dotf "digraph G {\n")
    (for/fold ((S (set))) (((s ts) graph))
      (let ((si (state->statei s)))
        (unless (set-member? S si)
          (fprintf dotf "~a [label=\"~a | ~a\"];\n" si si (state-repr s)))
        (for/fold ((S (set-add S si))) ((t ts))
          (match-let (((transition s* E) t))
            (let ((si* (state->statei s*)))
              (unless (set-member? S si*)
                (fprintf dotf "~a [label=\"~a | ~a\"];\n" si* si* (state-repr s*)))
              (fprintf dotf "~a -> ~a;\n" si si*)
              (set-add S si*))))))
    (fprintf dotf "}")
    (close-output-port dotf)))

(define (flow-test . ens)
  (when (null? ens)
    (set! ens '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat collatz rsa primtest factor nqueens)))
  (define (perform name e)
    (let* ((sys (type-mach-0 e))
           (flow-duration (system-duration sys))
           (flow-state-count (vector-length (system-states sys)))
           (flow-exit (system-exit sys))
           (flow-msg (if (eq? flow-exit 'ok) (answer-value sys) (system-msg sys))))
      (printf "~a states ~a time ~a σi ~a Ξi ~a | ~a\n"
              (~a name #:min-width 12)
              (~a (if (eq? flow-exit 'ok) flow-state-count (format ">~a" flow-state-count)) #:min-width 7)
              (~a flow-duration #:min-width 7)
              (~a 'σi #:min-width 4)              
              "1"              
              (~a flow-msg #:max-width 72))))
  (for-each (lambda (en) (perform en (eval en)))
            ens))

(define (server-flow-test)
  (parameterize ((CESK-TIMELIMIT 60))
    (apply flow-test '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2
                           sat collatz rsa primtest factor nqueens dderiv mceval)))); boyer))))


(define (memo-test . ens)
  
  (when (null? ens)
    (set! ens '(hellomemo helloset! hellomemoset!   ; sanity checks
                          fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 ; 'small' benchies
                          sat collatz rsa primtest factor))) ; > 1000 ms
  
  
  (printf "Warmup...\n\n")
  (type-mach-0 fib)
  (type-mach-0 fib-mut)
  (type-mach-0 loop2)
  (type-mach-0 collatz)
  (type-mach-0 primtest)
  (type-mach-0 factor)
  
  (printf "Benchmarks: ~a\n" ens)
  (for/list ((en ens))
    (for/list ((mach (list type-mach-0 type-mach-0m)))
      ;    (for/list ((mach (list conc-mach conc-mach-summ conc-mach-sa)))
      (let ((e (eval en)))
        (perform-benchmark en e mach)))))

(define server-results #f)
(define size-results #f)
(define time-results #f)
(define (server-memo-test)
  (parameterize ((CESK-TIMELIMIT 30))
    (let ((results (apply memo-test '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2
                                          sat collatz rsa primtest factor regex nqueens mceval boyer dderiv))))
      (set! server-results results)
      (set! size-results results)
      (set! time-results (filter (lambda (bench) (member (benchmark-name bench) '(sat collatz rsa primtest factor regex nqueens dderiv mceval boyer))) results))
      (printf "All results in server-results\nSize benchmarks in size-results\nTime benchmarks in time-results\n"))))

(define (sound-test)
  (for ((e (list sound2 sound3 sound4 sound5 sound6 sound7 sound8)))
    (printf "~a ~a      ~a ~a\n" (eval e) (conc-eval e) (type-eval-0 e) (type-eval-0m e))))

(struct benchmark (name state-count duration memo-count exit msg))

(define (benchmark-eval name e mach)
  (let* ((sys (mach e))
         (duration (system-duration sys))
         (state-count (vector-length (system-states sys)))
         ;(memo-table (system-memo-table sys))
         ;(read-table (system-read-table sys))
         (memo-count (system-memo-count sys))
         (exit (system-exit sys))
         (msg (if (eq? exit 'ok) (answer-value sys) (system-msg sys))))
    (when (and #|(THROW)|# (eq? exit 'error))
      (raise msg))
    (benchmark name state-count duration memo-count exit msg)))

(define (perform-benchmark name e mach)
  (printf (~a name #:min-width 12))
  (let* ((bench (benchmark-eval name e mach))
         (exit (benchmark-exit bench))
         (msg (benchmark-msg bench))
         (state-count (benchmark-state-count bench))
         (memo-count (benchmark-memo-count bench))
         (duration (benchmark-duration bench)))
    (printf "states ~a time ~a memo ~a | ~a\n"
            (~a (if (eq? exit 'ok) state-count (format ">~a" state-count)) #:min-width 7)
            (~a duration #:min-width 7)
            (~a memo-count #:min-width 4)
            (~a msg #:max-width 72))
    bench))