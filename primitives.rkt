  (define (prim-cons e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((a (alloc "%cons" e))
               (v (α (cons (car rands) (cadr rands))))
               (σ* (store-alloc σ a v)))
          (set (list (α (addr a)) σ* (set (fr)))))
        (set)))

  (define (prim-car e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let-values (((v E)
                      (for/fold ((v ⊥) (E (set))) ((w (γ (car rands))))
                        (match w
                          ((addr a)
                           (values (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                                     (match ww
                                       ((cons v-car _) (⊔ v v-car))
                                       (_ v)))
                                   (set-add E (rp a "car" (car («app»-aes e))))))
                          (_ (values v E))))))
          (set (list v σ E)))
        (set)))

  (define (prim-cdr e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let-values (((v E)
                      (for/fold ((v ⊥) (E (set))) ((w (γ (car rands))))
                        (match w
                          ((addr a)
                           (values (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                                     (match ww
                                       ((cons _ v-cdr) (⊔ v v-cdr))
                                       (_ v)))
                                   (set-add E (rp a "cdr" (car («app»-aes e))))))
                          (_ (values v E))))))
          (set (list v σ E)))
        (set)))

                        
(define (prim-set-car! e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let-values (((σ E)
                      (for/fold ((σ σ) (E (set))) ((w (γ (car rands))))
                        (match w
                          ((addr a)
                           (values (for/fold ((σ σ)) ((ww (γ (store-lookup σ a))))
                                     (match ww
                                       ((cons _ v-cdr) (store-update σ a (α (cons (cadr rands) v-cdr))))
                                       (_ σ)))
                                   (set-add E (wp a "car" (car («app»-aes e))))))
                          (_ (values σ E))))))
          (set (list (α 'undefined) σ E)))
        (set)))

(define (prim-set-cdr! e rands σ ι κ Ξ)
  (if (= (length rands) 2)
      (let-values (((σ E)
                    (for/fold ((σ σ) (E (set))) ((w (γ (car rands))))
                      (match w
                        ((addr a)
                         (values (for/fold ((σ σ)) ((ww (γ (store-lookup σ a))))
                                   (match ww
                                     ((cons v-car _) (store-update σ a (α (cons v-car (cadr rands)))))
                                     (_ σ)))
                                 (set-add E (wp a "cdr" (car («app»-aes e))))))
                        (_ (values σ E))))))
        (set (list (α 'undefined) σ E)))
      (set)))

  (define (prim-pair e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let ((v (for/fold ((v ⊥)) ((w (γ (car rands))))
                   (match w
                     ((addr a)
                      (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                        (⊔ v (α (pair? ww)))))
                     (_ (α #f))))))
          (set (list v σ (set))))
        (set)))

  (define (prim-to-string e rands σ ι κ Ξ)
    (define (helper v seen)
      (match v
        ((addr a)
         (if (set-member? seen a)
             (set (list (α (~a v)) σ (set)))
             (begin
               (apply set-union (set-map (γ (store-lookup σ a)) (lambda (w) (helper w (set-add seen a))))))))
        ((cons v1 v2)
         (let ((s1 (helper v1 seen))
               (s2 (helper v2 seen)))
           (for*/set ((sσ1 s1) (sσ2 s2))
             (list (α (~a (cons (car sσ1) (car sσ2)))) σ (set)))))
        (_ (set (list (α (~a v)) σ (set))))))
    (if (= (length rands) 1)
        (apply set-union (set-map (γ (car rands)) (lambda (w) (helper w (set)))))
        (set)))

  (define (eq?-helper v1 v2 σ)
    (match* (v1 v2)
      (((addr a1) (addr a2))
       (α (equal? a1 a2)))
      ((_ _) (α-eq? v1 v2))))

  (define (prim-eq? e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((w1 (γ (car rands)))
               (w2 (γ (cadr rands)))
               (v (for*/fold ((v ⊥)) ((v1 w1) (v2 w2)) (⊔ v (eq?-helper v1 v2 σ)))))
          (set (list v σ (set))))
        (set)))

  (define (prim-error e rands σ ι κ Ξ)
    (set))
