#lang racket

(require "general.rkt")
(require "ast.rkt")
(require "lattice.rkt")
(require "cesk.rkt")
(require "test.rkt")

(provide (all-defined-out))

;;
(define (outer-scope-declaration? decl e ast)
  (let up ((e e))
    (let ((p (parent e ast)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? decl (car x))
                   #t
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? decl x)
                 #t
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? decl x)
             #t
             (up p)))
        (_ (up p))))))

(define (inner-scope-declaration? decl e)
  (or (eq? decl e)
      (for/or ((e* (children e)))
        (inner-scope-declaration? decl e*))))

(define (get-declaration name e ast)
  (let up ((e e))
    (let ((p (parent e ast)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? name («id»-x (car x)))
                   (car x)
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? name («id»-x x))
                 x
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? name («id»-x x))
             x
             (up p)))
        (_ (up p))))))

(define (fresh-analysis system)
  (let* ((graph (system-graph system))
         (Ξ (system-Ξ system))
         (initial (system-initial system))
         (ast (ev-e initial)))
    
    (define (handle-state state E fresh)
      (match state
        ((ev («set!» _ x ae) ρ ι κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (fresh? ae fresh ast)
               (set-add fresh decl)
               (set-remove fresh decl))))
        ((ev («let» _ x e0 e1) ρ ι κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (fresh? e0 fresh ast)
               (set-add fresh decl)
               (set-remove fresh decl))))
        ((ko v (cons (letk x e ρ) ι) κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (set-member? E (fr))
               (set-add fresh decl)
               ;(set-remove fresh decl)))) ; can never overrule ev let
               fresh)))
        (_ fresh)))
    
    (define (traverse S W Fκ Fς)
      (if (set-empty? W)
          Fς
          (let* ((sE (set-first W))
                 (state (car sE))
                 (E (cdr sE)))
            (if (set-member? S state)
                (traverse S (set-rest W) Fκ Fς)
                (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
                       (fresh (hash-ref Fκ κ (set)))
                       (fresh* (handle-state state E fresh))
                       (Fκ* (hash-set Fκ κ fresh*))
                       (Fς* (hash-set Fς state Fκ))
                       (ΔW (hash-ref graph state)))
                  (traverse (set-add S state) (set-union (set-rest W) ΔW) Fκ* Fς*))))))
    
    (traverse (set) (set (cons initial (set))) (hash) (hash))))

(define (fresh? e fresh ast)
  (match e
    ((«id» _ x)
     (let ((decl (get-declaration x e ast)))
       (set-member? fresh decl)))
    (_ #f)))

(define (state-κ s)
  (match s
    ((ev _ _ _ κ) κ)
    ((ko _ _ κ) κ)))

(define (call-state-analysis sys)
  (let* ((graph (system-graph sys))
         (σ (system-σ sys))
         (Ξ (system-Ξ sys))
         (γ (lattice-γ (system-lattice sys))))

    (for/fold ((call-states (hash))) (((s ts) graph))
      (match s
        ((ev (? «app»? e) ρ ι κ)
         (for/fold ((call-states call-states)) ((t ts))
           (match t
             ((transition (ev _ _ '() κ*) _)
              (let* ((A-existing (hash-ref call-states κ* (set)))
                     (A-updated (set-union A-existing (reachable (s-referenced s Ξ) σ γ))))
                (hash-set call-states κ* A-updated)))
             (_ call-states))))
        (_ call-states)))))

(define GENERATES "GEN")
(define OBSERVES "OBS")

(define (address-observable-effect? call-states)
  (lambda (eff κ)
    (let ((A (hash-ref call-states κ)))
      (match eff
        ((wv a _)
         (set-member? A a))
        ((wp a _ _)
         (set-member? A a))
        ((rv a _)
         (set-member? A a))
        ((rp a _ _)
         (set-member? A a))))))

(define (traverse-graph graph initial Ξ observable-effect?)

  (define (add-read-dep a λ R)
    (hash-set R a (set-add (hash-ref R a (set)) λ)))
  
  (define (add-observer λ F)
    (hash-set F λ (set-add (hash-ref F λ (set)) OBSERVES)))
  
  (define (add-observers a F O)
    (let ((λ-os (hash-ref O a (set))))
      (for/fold ((F F)) ((λ-o λ-os))
        (add-observer λ-o F))))
  
  (define (traverse-graph* S W F R O)
    (if (set-empty? W)
        F
        (let ((s (set-first W)))
          (if (set-member? S s)
              (traverse-graph* S (set-rest W) F R O)
              (let-values (((W* F* R* O*)
                            (for/fold ((W W) (F F) (R R) (O O)) ((t (hash-ref graph s (set))))
                              (match t
                                ((transition s* E)
                                 (let ((W (set-add (set-remove W s) s*)))
                                   (for/fold ((W W) (F F) (R R) (O O)) ((eff E))
                                     (match eff
                                       ((wv a _)
                                        (let ((λ-rs (hash-ref R a (set))))
                                          (let ((O (for/fold ((O O)) ((λ-r λ-rs))
                                                      (hash-set O a (set-add (hash-ref O a (set)) λ-r)))))
                                            (let ((F (for/fold ((F F)) ((κ (stack-contexts (state-κ s) Ξ)))
                                                       (if (observable-effect? eff κ)
                                                           (let ((λ (ctx-λ κ)))
                                                             (hash-set F λ (set-add (hash-ref F λ (set)) GENERATES)))
                                                           F))))
                                              (values W F R O)))))
                                       ((wp a n _)
                                        (let* ((res (cons a n))
                                              (λ-rs (hash-ref R res (set))))
                                          (let ((O (for/fold ((O O)) ((λ-r λ-rs))
                                                     (hash-set O res (set-add (hash-ref O res (set)) λ-r)))))
                                            (let ((F (for/fold ((F F)) ((κ (stack-contexts (state-κ s) Ξ)))
                                                       (if (observable-effect? eff κ)
                                                           (let ((λ (ctx-λ κ)))
                                                             (hash-set F λ (set-add (hash-ref F λ (set)) GENERATES)))
                                                           F))))
                                              (values W F R O)))))
                                       ((rv a _)
                                        (let-values (((F R)
                                                      (for/fold ((F F) (R R)) ((κ (stack-contexts (state-κ s) Ξ)))
                                                        (if (observable-effect? eff κ)
                                                            (let ((λ (ctx-λ κ)))
                                                              (values (add-observers a F O)
                                                                      (add-read-dep a λ R)))
                                                            (values F R)))))
                                          (values W F R O)))
                                       ((rp a n _)
                                        (let ((res (cons a n)))
                                          (let-values (((F R)
                                                        (for/fold ((F F) (R R)) ((κ (stack-contexts (state-κ s) Ξ)))
                                                          (if (observable-effect? eff κ)
                                                              (let ((λ (ctx-λ κ)))
                                                                (values (add-observers res F O)
                                                                        (add-read-dep res λ R)))
                                                              (values F R)))))
                                            (values W F R O))))
                                       (_ (values W F R O))))))))))
                (let* ((unchanged (and (equal? F F*) (equal? R R*) (equal? O O*)))
                       (S* (if unchanged (set-add S s) (set))))
                  (traverse-graph* S* W* F* R* O*)))))))
  
  (traverse-graph* (set) (set initial) (hash) (hash) (hash)))

(define (address-purity-analysis sys)
  (let* ((call-states (call-state-analysis sys))
         (observable-effect? (address-observable-effect? call-states)))
    (traverse-graph (system-graph sys) (system-initial sys) (system-Ξ sys) observable-effect?)))
    
(define PURE "PURE")
(define OBSERVER "OBS")
(define PROCEDURE "PROC")

(define (extend-to-applied F Ξ)
  (for/hash ((κ (hash-keys Ξ)))
    (let ((λ (ctx-λ κ)))
      (values λ (hash-ref F λ (set))))))

(define (F->C F)
  (for/hash (((λ f) F))
    (cond
      ((set-empty? f) (values λ PURE))
      ((set-member? f GENERATES) (values λ PROCEDURE))
      (else (values λ OBSERVES)))))

(define (print-purity-info C)
  (for (((λ c) C))
    (printf "~a -> ~a\n" (~a λ #:max-width 30) c)))

(define (count-classes C)
  (for/fold ((summary (hash))) (((λ c) C))
    (when (PRINT-PER-LAMBDA)
      (printf "~a -> ~a\n" (~a λ #:max-width 30) c))
    (hash-set summary c (add1 (hash-ref summary c 0)))))

(define (full-address-purity-benchmark sys)
  (purity-benchmark sys address-purity-analysis))

;(define (scope-address-purity-benchmark sys)
 ; (purity-benchmark sys scope-address-purity-analysis))


(define FLOW-TIME "flow-time")
(define STATE-COUNT "state-count")
(define FLOW-EXIT "flow-exit")
(define FLOW-MSG "flow-msg")
(define NUM-LAMBDAS "num-lambdas")
(define NUM-CALLED "num-called")

(define (purity-benchmark sys analysis)
  (define (nodes ast) (for/fold ((cs (list ast))) ((c (children ast))) (append cs (nodes c))))
  (define (lambdas ast) (filter «lam»? (nodes ast)))  
  (with-handlers ((exn:fail? (lambda (exc) (if (THROW) (raise exc) (hash 'exit 'error 'msg exc)))))
    (let* ((flow-exit (system-exit sys))
           (summary (make-hash)))
      (hash-set! summary FLOW-TIME (system-duration sys))
      (hash-set! summary STATE-COUNT (vector-length (system-states sys)))
      (hash-set! summary FLOW-EXIT flow-exit)
      (hash-set! summary FLOW-MSG (if (eq? flow-exit 'ok) (answer-value sys) (system-msg sys)))
      (when (eq? flow-exit 'ok)
        (let* ((initial (system-initial sys))
               (ast (ev-e initial))
               (Ξ (system-Ξ sys))
               (F (extend-to-applied (analysis sys) Ξ))
               (C (F->C F))
               (count-summary (count-classes C)))
          (for (((k v) count-summary))
            (hash-set! summary k v))
          (hash-set! summary NUM-LAMBDAS (length (lambdas ast)))
          (hash-set! summary NUM-CALLED (set-count (list->set (map (lambda (κ) (ctx-λ κ)) (hash-keys Ξ)))))))
      summary)))

(define (print-purity-summary summary)
  (let ((flow-time (hash-ref summary FLOW-TIME "?"))
        (state-count (hash-ref summary STATE-COUNT "?"))
        (exit (hash-ref summary FLOW-EXIT "?"))
        (num-lambdas (hash-ref summary NUM-LAMBDAS "?"))
        (num-called (hash-ref summary NUM-CALLED "?"))
        (num-pure (hash-ref summary PURE 0))
        (num-obs (hash-ref summary OBSERVER 0))
        (num-proc (hash-ref summary PROCEDURE 0))
        (msg (hash-ref summary FLOW-MSG "")))
    (printf "#~a flow-time ~a lams ~a called ~a pure ~a obs ~a proc ~a | ~a\n"
            (~a (if (eq? exit 'ok) state-count (format ">~a" state-count)) #:min-width 7)
            (~a flow-time #:min-width 7)
            (~a num-lambdas #:min-width 3)
            (~a num-called #:min-width 3)
            (~a num-pure #:min-width 2)
            (~a num-obs #:min-width 2)
            (~a num-proc #:min-width 2)
            (~a msg #:max-width 72))))
  

(define THROW (make-parameter #t))
(define PRINT-PER-LAMBDA (make-parameter #t))

(struct config (name handler))

(define purity-result #f)

(define (purity-test . ens)
  (when (null? ens)
    (set! ens '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat collatz rsa primtest factor)))
  (define configs (list (config 'fa full-address-purity-benchmark)
                        ))
  (define machs (list (cons 'conc conc-mach) (cons 'type type-mach-0)))
  (set! purity-result
  (parameterize ((PRINT-PER-LAMBDA #f))
    (for/list ((en ens))
      (let* ((e (eval en)))
        (cons en
              (for/list ((machc machs))
                (let* ((mach-name (car machc))
                       (mach (cdr machc))
                       (sys (mach e)))
                  (cons mach-name
                  (for/list ((config configs))
                    (printf "~a ~a ~a" (~a en #:min-width 14) (~a mach-name #:min-width 4) (~a (config-name config) #:min-width 5))
                    (let ((result ((config-handler config) sys)))
                      (print-purity-summary result)
                (cons (config-name config) result)))))))))))
  (printf "Results in purity-result\n"))

(define (server-purity-test)
  (parameterize ((CESK-TIMELIMIT 60) (THROW #f))
    (let ((results (apply purity-test '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat collatz rsa primtest factor
                                     nqueens dderiv destruct mceval
                                     ; regex boyer 
                                     )))) 
      (printf "Done.")
      results)))


#|
;; Lower-bound for printing time (if smaller, prints \epsilon), in seconds
(define TIMECUTOFF (make-parameter 1))
(define TIMEFORMAT (make-parameter
                    ;; Round to seconds by default: 1
                    (lambda (time) (format "~a''" (inexact->exact (round time))))
                    ;; Other possibility: 1.234''
                    ;; (lambda (n) (~a time "''"))
                    ))
(define (display-size-tex result)
  (define (to-states benchmark)
    (~a (if (eq? (benchmark-exit benchmark) 'user) "$>$" "") (benchmark-state-count benchmark)))
  
  (printf "\\begin{tabular}{lllll} Program & Variance & Base & Summarizing & Self-adjusting \\\\ \\hline \n")
  (for/list ((res result))
    (match res
      ((list res-0 res-0-summ res-0-sa res-1 res-1-summ res-1-sa)
       ;; 0-CFA
       (printf "\\code{~a}      & 0CFA         & ~a   & ~a     & ~a          \\\\"
               (~a "benchmark-name res-0") 
               (~a (to-states res-0))      
               (~a (to-states res-0-summ))
               (~a (to-states res-0-sa))
               )
       ;; 1-CFA
       (printf "                & 1CFA         & ~a   & ~a    & ~a          \\\\[6pt]\n"
               (~a (to-states res-1))
               (~a (to-states res-1-summ))
               (~a (to-states res-1-sa)) 
               ))))
  (printf "\\end{tabular}\n"))

(define (display-time-tex result)
  (define (to-time benchmark)
    (if (eq? (benchmark-exit benchmark) 'user)
        "$\\infty$"
        (let ((duration (benchmark-duration benchmark)))
          (if (< duration 1000)
              "$\\epsilon$" 
              (format "~a''" (inexact->exact (round (/ duration 1000))))))))
  
  (printf "\\begin{tabular}{lllll} Program & Variance & Base & Summarizing & Self-adjusting \\\\ \\hline \n")
  (for/list ((res result))
    (match res
      ((list res-0 res-0-summ res-0-sa res-1 res-1-summ res-1-sa)
       ;; 0-CFA
       (printf "\\code{~a}      & 0CFA         & ~a   & ~a      & ~a          \\\\"
               (~a "benchmark-name res-0") 
               (~a (to-time res-0))      
               (~a (to-time res-0-summ))
               (~a (to-time res-0-sa)))
       ;; 1-CFA
       (printf "                & 1CFA         & ~a   & ~a      & ~a          \\\\[6pt]\n"
               (~a (to-time res-1))
               (~a (to-time res-1-summ))
               (~a (to-time res-1-sa))))))
  (printf "\\end{tabular}\n"))


(define (mark-proc C λ)
  (hash-set C λ (set-add (hash-ref C λ) "GEN")))

(define (mark-obs C λ)
  (hash-set C λ (set-add (hash-ref C λ) "OBS")))

(define (add-read-dep R a decl λ)
  (let* ((key (cons a decl))
         (current-deps (hash-ref R key (set))))
    (if (set-member? current-deps λ)
        R
        (hash-set R key (set-add current-deps λ)))))

(define (add-potential-obs O a decl λ)
  (let* ((key (cons a decl))
         (current-os (hash-ref O key (set))))
    (if (set-member? current-os λ)
        O
        (hash-set O key (set-add current-os λ)))))

; ADDRESS
(define (handle-wv-address a x ctxs ctx-λ ctx-Aσ C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (Aσ (ctx-Aσ τ)))
          (if (member a Aσ)
              (let* ((λ (ctx-λ τ))
                     (C* (mark-proc C λ)))
                (stack-walk (set-rest ctxs) C*))
              (stack-walk (set-rest ctxs) C))))))
(define (handle-wp-address a n x ctxs ctx-λ ctx-Aσ C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (Aσ (ctx-Aσ τ)))
          (if (member a Aσ)
              (let* ((λ (ctx-λ τ))
                     (C* (mark-proc C λ)))
                (stack-walk (set-rest ctxs) C*))
              (stack-walk (set-rest ctxs) C))))))
(define (handle-rv-address a x ctxs ctx-λ ctx-Aσ ast C R O)
  (let ((decl (get-declaration («id»-x x) x ast)))
    (let stack-walk ((ctxs ctxs) (C C) (R R))
      (if (set-empty? ctxs)
          (values C R O)
          (let* ((τ (set-first ctxs))
                 (Aσ (ctx-Aσ τ)))
            (if (member a Aσ)
                (let* ((λ (ctx-λ τ))
                       (R* (add-read-dep R a decl λ))
                       (potential-o (hash-ref O (cons a decl) (set)))
                       (C* (if (set-member? potential-o λ)
                               (mark-obs C λ)
                               C)))
                  (stack-walk (set-rest ctxs) C* R*))
                (stack-walk (set-rest ctxs) C R)))))))
(define (handle-rp-address a n x ctxs ctx-λ ctx-Aσ C R O)
  (let stack-walk ((ctxs ctxs) (C C) (R R))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (Aσ (ctx-Aσ τ)))
          (if (member a Aσ)
              (let* ((λ (ctx-λ τ))
                     (R* (add-read-dep R a n λ))
                     (potential-o (hash-ref O (cons a n) (set)))
                     (C* (if (set-member? potential-o λ)
                             (mark-obs C λ)
                             C)))
                (stack-walk (set-rest ctxs) C* R*))
              (stack-walk (set-rest ctxs) C R))))))

; V SCOPE
(define (handle-wv-scope x ctxs ctx-λ ast C R O)
  (let ((decl (get-declaration («id»-x x) x ast)))
    (let stack-walk ((ctxs ctxs) (C C))
      (if (set-empty? ctxs)
          (values C R O)
          (let* ((τ (set-first ctxs))
                 (λ (ctx-λ τ)))
            (if (outer-scope-declaration? decl λ ast)
                (let ((C* (mark-proc C λ)))
                  (stack-walk (set-rest ctxs) C*))
                (stack-walk (set-rest ctxs) C)))))))
(define (handle-rv-scope a x ctxs ctx-λ ast C R O)
  (let ((decl (get-declaration («id»-x x) x ast)))
    (let stack-walk ((ctxs ctxs) (C C) (R R))
      (if (set-empty? ctxs)
          (values C R O)
          (let* ((τ (set-first ctxs))
                 (λ (ctx-λ τ)))
            (if (inner-scope-declaration? decl λ)
                (stack-walk (set-rest ctxs) C R)
                (if (outer-scope-declaration? decl λ ast)
                    (let* ((R* (add-read-dep R a decl λ))
                           (potential-o (hash-ref O (cons a decl) (set)))
                           (C* (if (set-member? potential-o λ)
                                   (mark-obs C λ)
                                   C)))
                      (stack-walk (set-rest ctxs) C* R*))
                    (stack-walk (set-rest ctxs) C R))))))))
; P FRESH
(define (handle-wp-fresh x ctxs ctx-λ Fκ ast C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((κ (set-first ctxs))
               (fresh (hash-ref Fκ κ (set))))
          (if (fresh? x fresh ast)
              (stack-walk (set-rest ctxs) C)
              (let* ((λ (ctx-λ κ))
                     (C* (mark-proc C λ)))
                (stack-walk (set-rest ctxs) C*)))))))
(define (handle-rp-fresh a n x ctxs ctx-λ Fκ ast C R O)
  (let stack-walk ((ctxs ctxs) (C C) (R R))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((κ (set-first ctxs))
               (fresh (hash-ref Fκ κ (set))))
          (if (fresh? x fresh ast)
              (stack-walk (set-rest ctxs) C R)
              (let* ((λ (ctx-λ κ))
                     (R* (add-read-dep R a n λ))
                     (potential-o (hash-ref O (cons a n) (set)))
                     (C* (if (set-member? potential-o λ)
                             (mark-obs C λ)
                             C)))
                (stack-walk (set-rest ctxs) C* R*)))))))

; FALLBACK
(define (handle-w ctxs ctx-λ C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (λ (ctx-λ τ))
               (C* (mark-proc C λ)))
          (stack-walk (set-rest ctxs) C*)))))

(define (handle-r a n ctxs ctx-λ C R O)
  (let stack-walk ((ctxs ctxs) (C C) (R R))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (λ (ctx-λ τ))
               (R* (add-read-dep R a n λ))
               (potential-o (hash-ref O (cons a n) (set)))
               (C* (if (set-member? potential-o λ)
                       (mark-obs C λ)
                       C)))
          (stack-walk (set-rest ctxs) C* R*)))))

(define (make-address-handler ctx-Aσ)
  (lambda (sys)
    (lambda (effect state ast Ξ ctx-λ C R O)
      (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
             (ctxs (stack-contexts κ Ξ)))
        (match effect
          ((wv a x)
           (let* ((decl (get-declaration («id»-x x) x ast))
                  (r-deps (hash-ref R (cons a decl) (set)))
                  (O* (let update-o ((O O) (r-deps r-deps))
                        (if (set-empty? r-deps)
                            O
                            (let* ((r-dep (set-first r-deps))
                                   (O* (add-potential-obs O a decl r-dep)))
                              (update-o O* (set-rest r-deps)))))))
             (handle-wv-address a x ctxs ctx-λ ctx-Aσ C R O)))
          ((wp a n x)
           (let* ((r-deps (hash-ref R (cons a n) (set)))
                  (O* (let update-o ((O O) (r-deps r-deps))
                        (if (set-empty? r-deps)
                            O
                            (let* ((r-dep (set-first r-deps))
                                   (O* (add-potential-obs O a n r-dep)))
                              (update-o O* (set-rest r-deps)))))))
             (handle-wp-address a n x ctxs ctx-λ ctx-Aσ C R O*)))
          ((rv a x)
           (handle-rv-address a x ctxs ctx-λ ctx-Aσ ast C R O))
          ((rp a n x)
           (handle-rp-address a n x ctxs ctx-λ ctx-Aσ C R O))
          (_ (values C R O)))))))

(define (make-non-address-handler)
  (lambda (sys)
    (let ((Fς (fresh-analysis sys)))
      (lambda (effect state ast Ξ ctx-λ C R O)
        (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
               (ctxs (stack-contexts κ Ξ)))
          (match effect
            ((wv a x)
             (let* ((decl (get-declaration («id»-x x) x ast))
                    (r-deps (hash-ref R (cons a decl) (set)))
                    (O* (let update-o ((O O) (r-deps r-deps))
                          (if (set-empty? r-deps)
                              O
                              (let* ((r-dep (set-first r-deps))
                                     (O* (add-potential-obs O a decl r-dep)))
                                (update-o O* (set-rest r-deps)))))))
               (handle-wv-scope x ctxs ctx-λ ast C R O*)))
            ((wp a n x)
             (let* ((r-deps (hash-ref R (cons a n) (set)))
                    (O* (let update-o ((O O) (r-deps r-deps))
                          (if (set-empty? r-deps)
                              O
                              (let* ((r-dep (set-first r-deps))
                                     (O* (add-potential-obs O a n r-dep)))
                                (update-o O* (set-rest r-deps)))))))
               (handle-wp-fresh x ctxs ctx-λ (hash-ref Fς state) ast C R O)))
            ((rv a x)
             (handle-rv-scope a x ctxs ctx-λ ast C R O))
            ((rp a n x)
             (handle-rp-fresh a n x ctxs ctx-λ (hash-ref Fς state) ast C R O))
            (_ (values C R O))))))))

|#