#lang racket

(require "general.rkt")
(require "ast.rkt")
(require "lattice.rkt")
(require "cesk.rkt")
(require "test.rkt")

(provide (all-defined-out))

;;

(define (inner-scope-declaration? decl e)
  (or (eq? decl e)
      (for/or ((e* (children e)))
        (inner-scope-declaration? decl e*))))

(define (free-variable? decl e)
  (set-member? (free e) decl))

(define (ctx-local-decl? decl κ)
  (and κ
       (let ((λ (ctx-λ κ)))
         (inner-scope-declaration? decl λ))))

(define (get-declaration name e parent)
  (let up ((e e))
    (let ((p (parent e)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? name («id»-x (car x)))
                   (car x)
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? name («id»-x x))
                 x
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? name («id»-x x))
             x
             (up p)))
        (_ (up p))))))

(struct escape-result (lams time) #:transparent)
(define (escape-analysis sys)
  (let* ((graph (system-graph sys))
         (initial (system-initial sys))
         (ast (ev-e initial))
         (α (lattice-α (system-lattice sys)))
         (γ (lattice-γ (system-lattice sys)))
         (state-σ (system-state-σ sys)))

    (define (touchesd d)
      (if (set? d)
          (for/fold ((as (set)) (lams (set))) ((v (in-set d)))
            (let-values (((A L) (touchesd v)))
              (values (set-union as A) (set-union lams L))))
          (match d
            ((clo lam ρ) (values (env-addresses ρ) (set lam)))
            ((letk _ _ ρ) (values (env-addresses ρ) (set)))
            ((letreck _ _ ρ) (values (env-addresses ρ) (set)))
            ((addr a) (values (set a) (set)))
            ((cons x y) (touchesd (set x y)))
            (_ (values (set) (set))))))
    
    (define (reachabled A L σ)
      (let loop ((A A) (L L) (R (set)))
        (if (set-empty? A)
            L
            (let ((a (set-first A)))
              (if (set-member? R a)
                  (loop (set-rest A) L R)
                  (let ((v (γ (store-lookup σ a))))
                    (let-values (((ΔA ΔL) (touchesd v)))
                      (loop (set-union (set-rest A) ΔA) (set-union L ΔL) (set-add R a)))))))))
    
    (define (eval-atom ae ρ σ) ; copied from cesk, but in principle can/should be provided in system
      (match ae
        ((«lit» _ v)
         (α v))
        ((«id» _ x)
         (let ((a (env-lookup ρ x)))
           (store-lookup σ a)))
        ((«lam» _ x e)
         (let ((cl (clo ae ρ)))
           (α cl)))
        ((«quo» _ atom)
         (α atom))
        (_ (error "cannot handle ae" ae))))

    (define (check-values ae ρ σ M)
      (let ((d (eval-atom ae ρ σ)))
        (let-values (((A L) (touchesd d)))
          (set-union M (reachabled A L σ)))))
    
    (define (handle-state s M)
        (match s
          ((ev («app» _ _ aes) ρ σi _ _)
           (let ((σ (state-σ σi)))
             (for/fold ((M M)) ((ae (in-list aes)))
               (set-union M (check-values ae ρ σ M)))))
          ((ev («set!» _ _ ae) ρ σi _ _)
           (let ((σ (state-σ σi)))
             (check-values ae ρ σ M)))
          ((ev («cons» _ ae1 ae2) ρ σi _ _)
           (let ((σ (state-σ σi)))
             (set-union (check-values ae1 ρ σ M) (check-values ae2 ρ σ M))))
          ((ev («set-car!» _ _ ae) ρ σi _ _)
           (let ((σ (state-σ σi)))
             (check-values ae ρ σ M)))
          ((ev («set-cdr!» _ _ ae) ρ σi _ _)
           (let ((σ (state-σ σi)))
             (check-values ae ρ σ M)))
          ((ev («vector-set!» _ _ _ ae) ρ σi _ _)
           (let ((σ (state-σ σi)))
             (check-values ae ρ σ M)))
          ((ev (? ae? ae) ρ σi '() _)
           (let ((σ (state-σ σi)))
             (check-values ae ρ σ M)))
          (_ M)))

    (define (traverse-graph graph)
      (for/fold ((M (set))) (((s t) (in-hash graph)))
        (let ((M* (handle-state s M)))
          M*)))


    (define start (current-milliseconds))
    (define M (traverse-graph graph))
    (define time (- (current-milliseconds) start))

    (escape-result M time)))


(define (print-escape-info M)
  (for ((λ M))
    (printf "~a\n" λ)))


(struct freshness-result (fresh? time))
(define (freshness-analysis sys escapes?)
  (define lattice (system-lattice sys))
  (define ⊥ (lattice-⊥ lattice))
  (define ⊔ (lattice-⊔ lattice))
  (define α (lattice-α lattice))
  ;(define γ (lattice-γ lattice))
  (define UNFRESH (α "unfresh"))
     
  (let* ((graph (system-graph sys))
         (Ξ (system-Ξ sys))
         (initial (system-initial sys))
         (ast (ev-e initial))
         (parent (make-parent ast)))

    (define (freshness ae Fκ)
      (match ae
        ((«id» _ x)
         (let* ((decl (get-declaration x ae parent)))
                (hash-ref Fκ decl UNFRESH)))
        (_ ⊥)))

    (define (propagate ψ ι κ Ξ Fs)
      (let ((ικGs (stack-pop ι κ Ξ (set))))
        (for/fold ((Fs Fs)) ((ικG ικGs))
          (let* ((ι* (car ικG))
                 (κ* (cadr ικG))
                 (Fκ (hash-ref Fs κ* (hash)))
                 (Fκ* (match ι*
                        ((cons (letk x e ρ*) ι*)
                         (let ((declx x))
                           ;(printf "~a ~a -> ~a ~a ~a\n" "?" (ctx->ctxi κ) (ctx->ctxi κ*) "?" declx)
                           (hash-set Fκ declx (⊔ (hash-ref Fκ x ⊥) ψ))))
                        ((cons (letreck x e ρ*) ι*)
                         (let ((declx x))
                           (hash-set Fκ declx (⊔ (hash-ref Fκ x ⊥) ψ)))) 
                        ((cons (haltk) _)
                         Fκ)
                        )))
            (hash-set Fs κ* Fκ*)))))
    
    (define (handle-state s Fs)
      ;(printf "handling ~a\n" (state->statei s))
      (match s
        ((ev (? ae? ae) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ (freshness ae Fκ)))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («quo» _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ UNFRESH))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («set!» _ x ae) ρ _ ι κ)
         (let ((declx (get-declaration («id»-x x) x parent)))
           
           (define (walk-stack-set S W Fs)
             (if (set-empty? W)
                 Fs
                 (let ((κdyn (set-first W)))
                   (if (set-member? S κdyn)
                       (walk-stack-set S (set-rest W) Fs)
                       (let ((κ (car κdyn)))
                         (if κ
                             (let* ((dyn (cdr κdyn))
                                    (Fκ (hash-ref Fs κ (hash)))
                                    (ψ (if dyn
                                           (freshness ae Fκ)
                                           UNFRESH))
                                    (Fκ* (hash-set Fκ declx (⊔ (hash-ref Fκ declx ⊥) ψ)))
                                    (Fs* (hash-set Fs κ Fκ*))
                                    (λ (ctx-λ κ))
                                    (ικs (stack-lookup Ξ κ))
                                    (dyn* (and dyn (not (escapes? λ))))
                                    (W* (set-union (set-rest W) (for/set ((ικ ικs)) (cons (cdr ικ) dyn*)))))
                               (walk-stack-set (set-add S κdyn) W* Fs*))
                             (walk-stack-set (set-add S κdyn) (set-rest W) Fs)))))))
           
           (let ((Fs* (walk-stack-set (set) (set (cons κ #t)) Fs)))
             (propagate ⊥ ι κ Ξ Fs*))))
        ((ev («cons» _ _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ ⊥))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («make-vector» _ _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ ⊥))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («car» _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ UNFRESH))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («cdr» _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ UNFRESH))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («vector-ref» _ _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ UNFRESH))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («set-car!» _ _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ ⊥))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («set-cdr!» _ _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ ⊥))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («vector-set!» _ _ _ _) _ _ ι κ)
         (let* ((Fκ (hash-ref Fs κ (hash)))
                (ψ ⊥))
           (propagate ψ ι κ Ξ Fs)))
        ((ev («let» _ x (? ae? ae) e1) _ _ ι κ) ; only on ae, and only for this impl (because of ae fastpath in CESK)
         (let* ((declx x)
                (Fκ (hash-ref Fs κ (hash)))
                (ψ (freshness ae Fκ))
                (Fκ* (hash-set Fκ declx (⊔ (hash-ref Fκ declx ⊥) ψ)))) ;hash-ref with ⊥, cause introducing! "alloc"
           (hash-set Fs κ Fκ*)))
        ((ev («let» _ _ _ _) _ _ _ _) ; only on ae, and only for this impl (because of ae fastpath in CESK)
         Fs)
        ((ev («letrec» _ x (? ae? ae) e1) _ _ ι κ) ; only on ae, and only for this impl (because of ae fastpath in CESK)
         (let* ((declx x)
                (Fκ (hash-ref Fs κ (hash)))
                (ψ (freshness ae Fκ))
                (Fκ* (hash-set Fκ declx (⊔ (hash-ref Fκ declx ⊥) ψ)))) ;hash-ref with ⊥, cause introducing!
           (hash-set Fs κ Fκ*)))
        ((ev («letrec» _ _ _ _) _ _ _ _) ; only on ae, and only for this impl (because of ae fastpath in CESK)
         Fs)
        ((ev («app» _ _ _) _ _ ι κ)
         (for/fold ((Fs Fs)) ((t (hash-ref graph s)))
           (let ((s* (transition-s t)))
             (match s*
               ((ev e ρ* _ _ κ*)
                (let ((Fκ* (for/fold ((Fκ (hash-ref Fs κ* (hash)))) ((name (hash-keys ρ*)))
                             (let ((decl (get-declaration name e parent)))
                               ;(printf "~a ~a -> ~a ~a ~a\n" (state->statei s) (ctx->ctxi κ) (ctx->ctxi κ*) name decl)
                               (hash-set Fκ decl (⊔ (hash-ref Fκ decl ⊥) UNFRESH))))))
                  (hash-set Fs κ* Fκ*)))
               ((ko _ _ _ κ)
                (propagate ⊥ ι κ Ξ Fs))))))
        ((ev («if» _ _ _ _) _ _ _ _)
         Fs)
        ((ko _ _ _ _)
         Fs)
        ))
  
  (define (traverse-graph S W Fs F)
    (if (set-empty? W)
        F
        (let ((s (set-first W)))
          (if (set-member? S s)
              (traverse-graph S (set-rest W) Fs F)
                (let* ((Fs* (handle-state s Fs))
                       (F* (hash-set F s Fs*)))
                  (let* ((W* (set-union (set-rest W) (for/set ((t (hash-ref graph s (set))))
                                                              (transition-s t))))
                         (unchanged (equal? Fs Fs*))
                         (S* (if unchanged (set-add S s) (set))))
                    (traverse-graph S* W* Fs* F*)))))))

    (define start (current-milliseconds))
    (define state->Fs (traverse-graph (set) (set initial) (hash) (hash)))
    (define time (- (current-milliseconds) start))

      (define (fresh? ae state κ)
        (match ae
          ((«id» _ x)
           (let* ((Fs (hash-ref state->Fs state))
                  (Fκ (hash-ref Fs κ))
                  (decl (get-declaration x ae parent))
                  (ψ (freshness ae Fκ)))
             (equal? ψ ⊥)))))
          ;(_ #t)))

    (define (print-fresh-info F)
      (for (((s Fs) F))
           (printf "~a ~a\n" (state->statei s) (state-repr s))
           (for (((κ Fκ) Fs))
                (printf "\t~a ~a\n" (ctx->ctxi κ) (~a (if κ (ctx-λ κ) #f) #:max-width 30))
                (for (((decl FU) Fκ))
                     (when (equal? FU ⊥)
                       (printf "\t\t~a -> ~a\n" decl FU))))
                (newline)))
    ;(print-fresh-info state->Fs)

    
    (freshness-result fresh? time)))

                  

(struct call-state-result (ctx->addrs time) #:transparent)
(define (call-state-analysis sys)
  (define graph (system-graph sys))
  (define state-σ (system-state-σ sys))
  (define Ξ (system-Ξ sys))
  (define γ (lattice-γ (system-lattice sys)))
  (define start (current-milliseconds))
  (define call-states (for/fold ((call-states (hash))) (((s ts) (in-hash graph)))
                        (match s
                          ((ev (? «app»? e) ρ σi ι κ)
                           (for/fold ((call-states call-states)) ((t (in-set ts)))
                             (match t
                               ((transition (ev _ _ _ '() κ*) _)
                                (let* ((A-existing (hash-ref call-states κ* (set)))
                                       (σ (state-σ σi))
                                       (A-updated (set-union A-existing (reachable (s-referenced s Ξ) σ γ))))
                                  ;(A-updated (set-union A-existing (list->set (hash-keys σ)))))
                                  (hash-set call-states κ* A-updated)))
                               (_ call-states))))
                          (_ call-states))))
  (define time (- (current-milliseconds) start))
  (call-state-result call-states time))


(define GENERATES "GEN")
(define OBSERVES "OBS")
(struct side-effect-result (lam->side-effects time) #:transparent)
(define (side-effect-analysis graph initial Ξ observable? escapes?)

  (define parent (make-parent (ev-e initial)))

  (define F (hash))
  (define Fi 0)

  (define (add-read-dep res lam R)
    ;(printf " R ~a " («lam»-l lam))
    (hash-set R res (set-add (hash-ref R res (set)) lam)))
  
  (define (add-effect! lam effect)
    ;(printf " OBS! ~a " («lam»-l lam))
    (define existing-effects (hash-ref F lam #f))
    (if existing-effects
        (unless (set-member? existing-effects effect)
          (set! Fi (add1 Fi))
          (set! F (hash-set F lam (set-add existing-effects effect))))
        (begin
          (set! Fi (add1 Fi))
          (set! F (hash-set F lam (set effect))))))

  (define (add-observers! res O)
    (let ((λ-os (in-set (hash-ref O res (set)))))
      (for ((λ-o λ-os))
           (add-effect! λ-o OBSERVES))))

  (define (traverse-graph S W R O)
    (unless (set-empty? W)
      (let ((s (set-first W)))
        (if (set-member? S s)
            (traverse-graph S (set-rest W) R O)
            (let ((old-Fi Fi))
              (let-values (((W* R* O*)
                            (for/fold ((W W) (R R) (O O)) ((t (hash-ref graph s (set))))
                              (match t
                                ((transition s* E)
                                 (let ((W (set-add (set-remove W s) s*)))
                                   (for/fold ((W W) (R R) (O O)) ((eff E))
                                     (let-values (((R O) (handle-effect eff s R O)))
                                       (values W R O)))))))))
                (let* ((unchanged (and (= old-Fi Fi) (equal? R R*) (equal? O O*)))
                       (S* (if unchanged (set-add S s) (set))))
                  (traverse-graph S* W* R* O*))))))))

  (define (update-O-write res R O)
    (let ((λ-rs (hash-ref R res (set))))
      (for/fold ((O O)) ((λ-r λ-rs))
        ;(printf " O ~a " («lam»-l λ-r))
        (hash-set O res (set-add (hash-ref O res (set)) λ-r)))))

  (define (walk-stack-write eff res s S W)
    (unless (set-empty? W)
      (let ((κdyn (set-first W)))
        (if (set-member? S κdyn)
            (walk-stack-write eff res s S (set-rest W))
            (let ((κ (car κdyn)))
              (if κ
                  (let ((dyn (cdr κdyn)))
                    (if (observable? eff κ s dyn)
                        (let* ((λ (ctx-λ κ))
                               (ικs (stack-lookup Ξ κ))
                               (dyn* (and dyn (not (escapes? λ)))))
                          (add-effect! λ GENERATES)
                          (walk-stack-write eff res s (set-add S κdyn) (set-union (set-rest W) (for/set ((ικ ικs)) (cons (cdr ικ) dyn*)))))
                        (walk-stack-write eff res s (set-add S κdyn) (set-rest W))))
                  (walk-stack-write eff res s S (set-rest W))))))))

  (define (walk-stack-read eff res s S W R O)
    (if (set-empty? W)
        R
        (let ((κdyn (set-first W)))
          (if (set-member? S κdyn)
              (walk-stack-read eff res s S (set-rest W) R O)
              (let ((κ (car κdyn)))
                (if κ
                    (let ((dyn (cdr κdyn))) 
                      (if (observable? eff κ s dyn)
                          (let* ((λ (ctx-λ κ))
                                 (R* (add-read-dep res λ R))
                                 (dyn* (and dyn (not (escapes? λ))))
                                 (ικs (stack-lookup Ξ κ)))
                            (add-observers! res O)
                            (walk-stack-read eff res s (set-add S κdyn) (set-union (set-rest W) (for/set ((ικ ικs)) (cons (cdr ικ) dyn*))) R* O))
                          (walk-stack-read eff res s (set-add S κdyn) (set-rest W) R O)))
                    (walk-stack-read eff res s S (set-rest W) R O)))))))

  (define (handle-read-effect eff res s R O)
    (let ((R* (walk-stack-read eff res s (set) (set (cons (state-κ s) #t)) R O)))
      (values R* O)))

  (define (handle-write-effect eff res s R O)
    (let ((O* (update-O-write res R O)))
      (walk-stack-write eff res s (set) (set (cons (state-κ s) #t)))
      (values R O*)))
    
  (define (handle-effect eff s R O)
    ;(printf "\ns ~a effect ~a " (state->statei s) eff)
    (match eff
      ((wv a x)
       (handle-write-effect eff a s R O))
      ((wp a n x)
       (handle-write-effect eff (cons a n) s R O))
      ((rv a x)
       (handle-read-effect eff a s R O))
      ((rp a n x)
       (handle-read-effect eff (cons a n) s R O))
      (_ (values R O))))

  (define (extend-to-applied)
    (for/hash ((κ (hash-keys Ξ)))
              (let ((lam (ctx-λ κ)))
                (values lam (hash-ref F lam (set))))))
  
  (define start (current-milliseconds))
  (traverse-graph (set) (set initial) (hash) (hash))
  (define lam->side-effects (extend-to-applied))
  (define time (- (current-milliseconds) start))
  (side-effect-result lam->side-effects time))

(define (a-observable-effect? call-states)
  (lambda (eff κ s dyn)
    (match eff
      ((wv a _)
       (let ((A (hash-ref call-states κ)))
         (set-member? A a)))
      ((wp a _ _)
       (let ((A (hash-ref call-states κ)))
         (set-member? A a)))
      ((rv a _)
       (let ((A (hash-ref call-states κ)))
         (set-member? A a)))
      ((rp a _ _)
       (let ((A (hash-ref call-states κ)))
         (set-member? A a))))))

(define (sa-observable-variable-effect? a x κ dyn call-states parent)
  (if (and dyn
           (let ((decl (get-declaration («id»-x x) x parent))
                 (λ (ctx-λ κ)))
             (inner-scope-declaration? decl λ)))
      #f
      (let ((A (hash-ref call-states κ)))
              (set-member? A a))))

(define (fa-observable-property-effect? a x s κ dyn call-states fresh?)
  (if (and dyn
           (fresh? x s κ))
      #f
      (let ((A (hash-ref call-states κ)))
        (set-member? A a))))

(define (sa-observable-effect? call-states parent)
  (lambda (eff κ s dyn)
    (match eff
      ((wv a x)
       (sa-observable-variable-effect? a x κ dyn call-states parent))
      ((wp a _ _)
       (let ((A (hash-ref call-states κ)))
         (set-member? A a)))
      ((rv a x)
       (sa-observable-variable-effect? a x κ dyn call-states parent))
      ((rp a _ _)
       (let ((A (hash-ref call-states κ)))
         (set-member? A a))))))

(define (sfa-observable-effect? call-states parent fresh?)
  (lambda (eff κ s dyn)
    (match eff
      ((wv a x)
       (sa-observable-variable-effect? a x κ dyn call-states parent))
      ((wp a _ x)
       (fa-observable-property-effect? a x s κ dyn call-states fresh?))
      ((rv a x)
       (sa-observable-variable-effect? a x κ dyn call-states parent))
      ((rp a _ x)
       (fa-observable-property-effect? a x s κ dyn call-states fresh?)))))

(define (a-side-effect-analysis sys call-states)
  (let* ((observable? (a-observable-effect? call-states))
         (escapes? (lambda _ #t)))
    (side-effect-analysis (system-graph sys) (system-initial sys) (system-Ξ sys) observable? escapes?)))
    
(define (sa-side-effect-analysis sys call-states)
  (let* ((initial (system-initial sys))
         (ast (ev-e initial))
         (parent (make-parent ast))
         (lattice (system-lattice sys))
         (⊥ (lattice-⊥ lattice))
         (⊔ (lattice-⊔ lattice))
         (escapes? (lambda _ #t))
         (observable? (sa-observable-effect? call-states parent)))
    (side-effect-analysis (system-graph sys) (system-initial sys) (system-Ξ sys) observable? escapes?)))

(define (sfa-side-effect-analysis sys call-states fresh?)
  (let* ((initial (system-initial sys))
         (ast (ev-e initial))
         (parent (make-parent ast))
         (lattice (system-lattice sys))
         (⊥ (lattice-⊥ lattice))
         (⊔ (lattice-⊔ lattice))
         (escapes? (lambda _ #t))
         ;(F (fresh-analysis sys ⊥ ⊔ escapes?))
         (observable? (sfa-observable-effect? call-states parent fresh?)))
    (side-effect-analysis (system-graph sys) (system-initial sys) (system-Ξ sys) observable? escapes?)))

(define (msfa-side-effect-analysis sys call-states fresh? esc-lams)
  (let* ((initial (system-initial sys))
         (ast (ev-e initial))
         (parent (make-parent ast))
         (lattice (system-lattice sys))
         (⊥ (lattice-⊥ lattice))
         (⊔ (lattice-⊔ lattice))
         (escapes? (lambda (lam) (set-member? esc-lams lam)))
         (observable? (sfa-observable-effect? call-states parent fresh?)))
    (side-effect-analysis (system-graph sys) (system-initial sys) (system-Ξ sys) observable? escapes?)))

(define PURE "PURE")
(define OBSERVER "OBS")
(define PROCEDURE "PROC")
(define IMPURE "IMPURE")
(define (gl-classifier side-effects)
  (cond ((set-empty? side-effects) PURE)
        ((set-member? side-effects GENERATES) PROCEDURE)
        ((set-member? side-effects OBSERVES) OBSERVER)
        (else (error "?"))))

(define (purity-analysis lam->side-effects classifier) 
  (for/hash (((lam side-effects) lam->side-effects))
     (values lam (classifier side-effects))))

;(define (print-purity-info C)
;  (for (((λ c) C))
;    (printf "~a -> ~a\n" (~a λ #:max-width 30) c)))

(define (count-classes lam->class)
  (for/fold ((class->count (hash))) (((lam clss) lam->class))
    (when (PRINT-PER-LAMBDA)
      (printf "~a -> ~a\n" (~a lam #:max-width 30) clss))
    (hash-set class->count clss (add1 (hash-ref class->count clss 0)))))
  
(define (side-effect-pattern lam->side-effects lams)
  (map (lambda (lam) (hash-ref lam->side-effects lam #f)) (sort lams < #:key «lam»-l)))

(define (side-effect-patterns-match? expected actual)
  (if (null? expected)
      (null? actual)
      (let ((s1 (car expected)))
        (and (or (not s1) (equal? s1 (car actual))) (side-effect-patterns-match? (cdr expected) (cdr actual))))))

(define (nodes ast) (for/fold ((cs (list ast))) ((c (children ast))) (append cs (nodes c))))
(define (lambdas ast) (filter «lam»? (nodes ast)))

(define (purity-benchmark e mach expected)
  (newline)
  (printf "eval... ")
  (define sys (mach e))
  (define flow-time (system-duration sys))
  (define exit (system-exit sys))
  (printf "~a ms ~a\n" flow-time exit)
  (when (not (eq? 'ok exit))
    (define msg (system-msg sys))
    (printf "~a\n" msg)
    (hash 'exit 'error 'msg msg))
  (define state-count (vector-length (system-states sys)))
  (define result-value (answer-value sys))
  (printf "state-count ~a value ~a\n" state-count (~a result-value #:max-width 80))
  (define initial (system-initial sys))
  (define ast (ev-e initial))
  (define Ξ (system-Ξ sys))
  (define lattice (system-lattice sys))
  (define ⊥ (lattice-⊥ lattice))
  (define ⊔ (lattice-⊔ lattice))
  (define lams (sort (lambdas ast) < #:key «lam»-l))
  (define lam-count (length lams))
  (define called-count (set-count (list->set (map ctx-λ (hash-keys Ξ)))))
  
  (printf "escape analysis... ")
  (define er (escape-analysis sys))
  (define escape-time (escape-result-time er))
  (printf "~a ms\n" escape-time)
  (define esc-lams (escape-result-lams er))

  (printf "freshness analysis without esc... ")
  (define fr (freshness-analysis sys (lambda _ #t)))
  (define freshness-time (freshness-result-time fr))
  (printf "~a ms\n" freshness-time)
  (define fresh? (freshness-result-fresh? fr))
  
  (printf "freshness analysis with esc... ")
  (define fr-esc (freshness-analysis sys (lambda (lam) (set-member? esc-lams lam))))
  (define freshness-esc-time (freshness-result-time fr-esc))
  (printf "~a ms\n" freshness-esc-time)
  (define fresh?-esc (freshness-result-fresh? fr-esc))
  
  (printf "call-state analysis... ")
  (define csr (call-state-analysis sys))
  (define call-state-time (call-state-result-time csr))
  (printf "~a ms\n" call-state-time)
  (define ctx->addrs (call-state-result-ctx->addrs csr))

  (define (handle-side-effect-result ser)
    (define side-effect-time (side-effect-result-time ser))
    (printf "~a ms\n" side-effect-time)
    (define lam->side-effects (side-effect-result-lam->side-effects ser))
    (define purity (purity-analysis lam->side-effects gl-classifier))
    (define class-count (count-classes purity))
    (define gen-count (for/sum ((side-effects (hash-values lam->side-effects))) (if (set-member? side-effects GENERATES) 1 0)))
    (define obs-count (for/sum ((side-effects (hash-values lam->side-effects))) (if (set-member? side-effects OBSERVES) 1 0)))
    (define correct (if expected
                        (let ((actual (side-effect-pattern lam->side-effects lams)))
                          (if (side-effect-patterns-match? expected actual)
                              "OK"
                              (begin
                                ;(printf "expected ~a\ngot ~a\n" expected actual)
                                "NOK")))
                        "?"))
    (hash 'side-effect-time side-effect-time 'class-count class-count 'gen-count gen-count 'obs-count obs-count 'lam->side-effects lam->side-effects 'correct correct))

  (printf "a-side-effect analysis... ")
  (define a-ser (a-side-effect-analysis sys ctx->addrs))
  (define a-results (handle-side-effect-result a-ser))
  
  (printf "sa-side-effect analysis... ")
  (define sa-ser (sa-side-effect-analysis sys ctx->addrs))
  (define sa-results (handle-side-effect-result sa-ser))

  (printf "sfa-side-effect analysis... ")
  (define sfa-ser (sfa-side-effect-analysis sys ctx->addrs fresh?))
  (define sfa-results (handle-side-effect-result sfa-ser))

  (printf "msfa-side-effect analysis... ")
  (define msfa-ser (msfa-side-effect-analysis sys ctx->addrs fresh?-esc esc-lams))
  (define msfa-results (handle-side-effect-result msfa-ser))

  (hash 'exit 'ok 'msg result-value 'flow-time flow-time 'state-count state-count 'lam-count lam-count 'called-count called-count
        'a a-results 'sa sa-results 'sfa sfa-results 'msfa msfa-results
        'call-state-time call-state-time 'escape-time escape-time 'freshness-time freshness-time 'freshness-esc-time freshness-esc-time
        ))

(define THROW (make-parameter #t))
(define PRINT-PER-LAMBDA (make-parameter #f))

(define purity-result #f)

(define (se-subsumes? se1 se2)
  (for/and (((lam side-effects2) se2))
           (let ((side-effects1 (hash-ref se1 lam (set))))
             (subset? side-effects2 side-effects1))))

(define (perform-purity-test tests)
               
  (set! purity-result
  (for/list ((test tests))
       (newline)
       (define name (car test))
       (define e (cadr test))
       (define expected (cddr test))
       (printf "\n~a\n" name)
       
       (define conc-results (purity-benchmark e conc-mach expected))
       (define conc-a-lam->side-effects (hash-ref (hash-ref conc-results 'a) 'lam->side-effects))
       (define conc-sa-lam->side-effects (hash-ref (hash-ref conc-results 'sa) 'lam->side-effects))
       (define conc-sfa-lam->side-effects (hash-ref (hash-ref conc-results 'sfa) 'lam->side-effects))
       (define conc-msfa-lam->side-effects (hash-ref (hash-ref conc-results 'msfa) 'lam->side-effects))
       
       (define type-results (purity-benchmark e type-mach-0 expected))
       (define type-a-lam->side-effects (hash-ref (hash-ref type-results 'a) 'lam->side-effects))
       (define type-sa-lam->side-effects (hash-ref (hash-ref type-results 'sa) 'lam->side-effects))
       (define type-sfa-lam->side-effects (hash-ref (hash-ref type-results 'sfa) 'lam->side-effects))
       (define type-msfa-lam->side-effects (hash-ref (hash-ref type-results 'msfa) 'lam->side-effects))

       ; (CORRECTNESS) conc-a result must be correct
       (unless (eq? "OK" (hash-ref (hash-ref conc-results 'a) 'correct))
         (error "conc-a"))
       
       ; (SOUNDNESS) all conc results must be equal
       (unless (equal? conc-a-lam->side-effects conc-sa-lam->side-effects)
         (error "conc-sa"))
       (unless (equal? conc-a-lam->side-effects conc-sfa-lam->side-effects)
         (error "conc-sfa"))
       (unless (equal? conc-a-lam->side-effects conc-msfa-lam->side-effects)
         (error "conc-msfa"))

       ; (SOUNDNESS) all type results must subsume conc results
       (unless (se-subsumes? type-a-lam->side-effects conc-a-lam->side-effects)
         (error "type-a"))
       (unless (se-subsumes? type-sa-lam->side-effects conc-a-lam->side-effects)
         (error "type-sa"))
       (unless (se-subsumes? type-sfa-lam->side-effects conc-a-lam->side-effects)
         (error "type-sfa"))
       (unless (se-subsumes? type-msfa-lam->side-effects conc-a-lam->side-effects)
         (error "type-msfa"))

       ; (USEFULNESS) extra analyses must improve results (less-optimized subsumes more-optimized)
       (unless (se-subsumes? type-a-lam->side-effects type-sa-lam->side-effects)
         (error "type-a -> sa"))
       (unless (se-subsumes? type-sa-lam->side-effects type-sfa-lam->side-effects)
         (error "type-sa -> sfa"))
       (unless (se-subsumes? type-sfa-lam->side-effects type-msfa-lam->side-effects)
         (error "type-sfa -> msfa"))

       (list name conc-results type-results)
       ))
  (newline)
  (newline)
  (print-purity-result purity-result)
  )


(define (print-purity-result result)

  (define correct-counts (make-hash))
  (define (add1-correct-count! mach config)
    (let ((existing (hash-ref correct-counts (cons mach config) 0)))
      (hash-set! correct-counts (cons mach config) (add1 existing))))
  (define benefits-from-freshness (mutable-set))
  (define benefits-from-escape (mutable-set)) ; w.r.t. freshness
  
  (define (~time ms)
    (~a 
     (if (< ms 1000)
         "eps" 
         (format "~a''" (inexact->exact (round (/ ms 1000)))))
     #:min-width 5))

  (define (print-config-result mach name result)
    (define class-count (hash-ref result 'class-count))
    (define correct (hash-ref result 'correct))
    (when (eq? "OK" correct)
      (add1-correct-count! mach name))
    (printf "~a ~a pure ~a obs ~a proc ~a | gen ~a obs ~a | se ~a\n"
            (~a name #:min-width 4)
            (~a correct #:min-width 4)
            (~a (hash-ref class-count PURE 0) #:min-width 2)
            (~a (hash-ref class-count OBSERVER 0) #:min-width 2)
            (~a (hash-ref class-count PROCEDURE 0) #:min-width 2)
            (~a (hash-ref result 'gen-count) #:min-width 2)
            (~a (hash-ref result 'obs-count) #:min-width 2)
            (~time (hash-ref result 'side-effect-time))
            ))
  
  (define (print-mach-result benchmark-name name result)
    (define exit (hash-ref result 'exit))
    (define msg (hash-ref result 'msg))
    (define state-count (hash-ref result 'state-count))
    (printf "~a states ~a lams ~a called ~a | call ~a esc ~a fresh ~a fresh-esc ~a | ~a\n"
            name
            (~a (if (eq? exit 'ok) state-count (format ">~a" state-count)) #:min-width 7)
            (hash-ref result 'lam-count) (hash-ref result 'called-count)
            (~time (hash-ref result 'call-state-time))
            (~time (hash-ref result 'escape-time))
            (~time (hash-ref result 'freshness-time))
            (~time (hash-ref result 'freshness-esc-time))
            (~a msg #:max-width 72))
    (define a-result (hash-ref result 'a))
    (define sa-result (hash-ref result 'sa))
    (define sfa-result (hash-ref result 'sfa))
    (define msfa-result (hash-ref result 'msfa))
    (print-config-result name "a" a-result)
    (print-config-result name "sa" sa-result)
    (print-config-result name "sfa" sfa-result)
    (print-config-result name "msfa" msfa-result)
    (when (or (< (hash-ref sfa-result 'gen-count) (hash-ref a-result 'gen-count))
              (< (hash-ref sfa-result 'obs-count) (hash-ref a-result 'obs-count)))
      (set-add! benefits-from-freshness benchmark-name))
    (when (or (< (hash-ref msfa-result 'gen-count) (hash-ref sfa-result 'gen-count))
              (< (hash-ref msfa-result 'obs-count) (hash-ref sfa-result 'obs-count)))
      (set-add! benefits-from-escape benchmark-name))
    )
  
  
  (for ((r result))
       (let ((benchmark-name (car r)))
         (printf "~a\n" benchmark-name)
         (print-mach-result benchmark-name "conc" (cadr r))
         (print-mach-result benchmark-name "type" (caddr r))))

  (printf "conc-a    ~a\n" (hash-ref correct-counts (cons "conc" "a") 0))
  (printf "conc-sa   ~a\n" (hash-ref correct-counts (cons "conc" "sa") 0))
  (printf "conc-sfa  ~a\n" (hash-ref correct-counts (cons "conc" "sfa") 0))
  (printf "conc-msfa ~a\n" (hash-ref correct-counts (cons "conc" "msfa") 0))
  (printf "type-a    ~a\n" (hash-ref correct-counts (cons "type" "a") 0))
  (printf "type-sa   ~a\n" (hash-ref correct-counts (cons "type" "sa") 0))
  (printf "type-sfa  ~a\n" (hash-ref correct-counts (cons "type" "sfa") 0))
  (printf "type-msfa ~a\n" (hash-ref correct-counts (cons "type" "msfa") 0))
  (printf "benefits from freshness: (~a) ~a\n" (set-count benefits-from-freshness) benefits-from-freshness)
  (printf "benefits from escape   : (~a) ~a\n" (set-count benefits-from-escape) benefits-from-escape)
  )


(define (a-se sys)
  (printf "call-state analysis... ")
  (define csr (call-state-analysis sys))
  (define call-state-time (call-state-result-time csr))
  (printf "~a ms\n" call-state-time)
  (define ctx->addrs (call-state-result-ctx->addrs csr))
  (printf "a-side-effect analysis... ")
  (define a-ser (a-side-effect-analysis sys ctx->addrs))
  (define side-effect-time (side-effect-result-time a-ser))
  (printf "~a ms\n" side-effect-time)
  (define lam->side-effects (side-effect-result-lam->side-effects a-ser))
  (for (((lam side-effects) lam->side-effects))
       (printf "~a ~a\n" (~a lam #:max-width 50) side-effects))
  (side-effect-pattern lam->side-effects (lambdas (ev-e (system-initial sys)))))

#|
(define t2 '(letrec ((f (lambda (h) (let ((z (cons 1 2))) (if h (h) (f (lambda () (set-car! z 3)))))))) (f #f)))
(define sys2 (conc-mach t2))
(generate-dot (system-graph sys2) "t2")

(let* ((lattice (system-lattice sys2))
       (⊥ (lattice-⊥ lattice))
       (⊔ (lattice-⊔ lattice))
       (M (escape-analysis sys2))
       (escapes? (lambda (λ) (set-member? M λ)))
       (F (fresh-analysis sys2 ⊥ ⊔ escapes?)))
  (print-fresh-info F)
  (print-escape-info M)
  (parameterize ((PRINT-PER-LAMBDA #t))
    (print-purity-info (msfa-purity-analysis sys2))))




(define t1 '(letrec ((make-grid (lambda (start dims)
                                  (let ((v (make-vector dims start)))
                                    (let ((_43 (zero? dims)))
                                      (let ((_44 (not _43)))
                                        (let ((_54 (if _44
                                                       (letrec ((loop (lambda (i)
                                                                        (let ((_45 dims))
                                                                          (let ((_46 (>= i _45)))
                                                                            (if _46
                                                                                #t
                                                                                (let ((_47 (- dims 1)))
                                                                                  (let ((_50 (make-grid start _47)))
                                                                                    (let ((_51 (vector-set! v i _50)))
                                                                                      (let ((_53 (+ i 1)))
                                                                                        (loop _53)))))))))))
                                                         (loop 0))
                                                       #t)))
                                          v)))))))
              (make-grid 0 2)))

(define sys1 (type-mach-0 t1))
(generate-dot (system-graph sys1) "t1")
(print-fresh-info (fresh-analysis sys1 (set) set-union))
(print-variable-info (variable-analysis sys1))
(print-purity-info (sfa-purity-analysis sys1))

(define t3 '(letrec ((f (lambda (h) (let ((z (cons 1 2))) (if h (h) (f (lambda () (set-car! z 3)))))))) (f #f)))
(define sys3 (conc-mach t3))
(generate-dot (system-graph sys3) "t3")
(parameterize ((PRINT-PER-LAMBDA #t))
  (print-purity-info (a-purity-analysis sys3))
  (newline)
  (print-purity-info (sa-purity-analysis sys3))
  (newline)
  (print-purity-info (sfa-purity-analysis sys3))
  (newline)
  (print-fresh-info (fresh-analysis sys3 (set) set-union))
  )

;; Lower-bound for printing time (if smaller, prints \epsilon), in seconds
(define TIMECUTOFF (make-parameter 1))
(define TIMEFORMAT (make-parameter
                    ;; Round to seconds by default: 1
                    (lambda (time) (format "~a''" (inexact->exact (round time))))
                    ;; Other possibility: 1.234''
                    ;; (lambda (n) (~a time "''"))
                    ))
(define (display-size-tex result)
  (define (to-states benchmark)
    (~a (if (eq? (benchmark-exit benchmark) 'user) "$>$" "") (benchmark-state-count benchmark)))
  
  (printf "\\begin{tabular}{lllll} Program & Variance & Base & Summarizing & Self-adjusting \\\\ \\hline \n")
  (for/list ((res result))
    (match res
      ((list res-0 res-0-summ res-0-sa res-1 res-1-summ res-1-sa)
       ;; 0-CFA
       (printf "\\code{~a}      & 0CFA         & ~a   & ~a     & ~a          \\\\"
               (~a "benchmark-name res-0") 
               (~a (to-states res-0))      
               (~a (to-states res-0-summ))
               (~a (to-states res-0-sa))
               )
       ;; 1-CFA
       (printf "                & 1CFA         & ~a   & ~a    & ~a          \\\\[6pt]\n"
               (~a (to-states res-1))
               (~a (to-states res-1-summ))
               (~a (to-states res-1-sa)) 
               ))))
  (printf "\\end{tabular}\n"))

(define (display-time-tex result)
  (define (to-time benchmark)
    (if (eq? (benchmark-exit benchmark) 'user)
        "$\\infty$"
        (let ((duration (benchmark-duration benchmark)))
          (if (< duration 1000)
              "$\\epsilon$" 
              (format "~a''" (inexact->exact (round (/ duration 1000))))))))
  
  (printf "\\begin{tabular}{lllll} Program & Variance & Base & Summarizing & Self-adjusting \\\\ \\hline \n")
  (for/list ((res result))
    (match res
      ((list res-0 res-0-summ res-0-sa res-1 res-1-summ res-1-sa)
       ;; 0-CFA
       (printf "\\code{~a}      & 0CFA         & ~a   & ~a      & ~a          \\\\"
               (~a "benchmark-name res-0") 
               (~a (to-time res-0))      
               (~a (to-time res-0-summ))
               (~a (to-time res-0-sa)))
       ;; 1-CFA
       (printf "                & 1CFA         & ~a   & ~a      & ~a          \\\\[6pt]\n"
               (~a (to-time res-1))
               (~a (to-time res-1-summ))
               (~a (to-time res-1-sa))))))
  (printf "\\end{tabular}\n"))
|#