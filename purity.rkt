#lang racket
;(require (submod racket/performance-hint))

(require "general.rkt")
(require "ast.rkt")
(require "lattice.rkt")
(require "cesk.rkt")
(require "test.rkt")

(provide (all-defined-out))

;;
(define (outer-scope-declaration? decl e ast)
  (let up ((e e))
    (let ((p (parent e ast)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? decl (car x))
                   #t
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? decl x)
                 #t
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? decl x)
             #t
             (up p)))
        (_ (up p))))))

(define (inner-scope-declaration? decl e)
  (or (eq? decl e)
      (for/or ((e* (children e)))
        (inner-scope-declaration? decl e*))))

(define (get-declaration name e ast)
  (let up ((e e))
    (let ((p (parent e ast)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? name («id»-x (car x)))
                   (car x)
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? name («id»-x x))
                 x
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? name («id»-x x))
             x
             (up p)))
        (_ (up p))))))

(define (fresh-analysis system)
  (let* ((graph (system-graph system))
         (Ξ (system-Ξ system))
         (initial (system-initial system))
         (ast (ev-e initial)))
    
    (define (handle-state state E fresh)
      (match state
        ((ev («set!» _ x ae) ρ ι κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (fresh? ae fresh ast)
               (set-add fresh decl)
               (set-remove fresh decl))))
        ((ev («let» _ x e0 e1) ρ ι κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (fresh? e0 fresh ast)
               (set-add fresh decl)
               (set-remove fresh decl))))
        ((ko v (cons (letk x e ρ) ι) κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (set-member? E (fr))
               (set-add fresh decl)
               ;(set-remove fresh decl)))) ; can never overrule ev let
               fresh)))
        (_ fresh)))
    
    (define (traverse S W Fκ Fς)
      (if (set-empty? W)
          Fς
          (let* ((sE (set-first W))
                 (state (car sE))
                 (E (cdr sE)))
            (if (set-member? S state)
                (traverse S (set-rest W) Fκ Fς)
                (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
                       (fresh (hash-ref Fκ κ (set)))
                       (fresh* (handle-state state E fresh))
                       (Fκ* (hash-set Fκ κ fresh*))
                       (Fς* (hash-set Fς state Fκ))
                       (ΔW (hash-ref graph state)))
                  (traverse (set-add S state) (set-union (set-rest W) ΔW) Fκ* Fς*))))))
    
    (traverse (set) (set (cons initial (set))) (hash) (hash))))

(define (fresh? e fresh ast)
  (match e
    ((«id» _ x)
     (let ((decl (get-declaration x e ast)))
       (set-member? fresh decl)))
    (_ #f)))

(define (state-repr s)
  (match s
    ((ev e ρ ι κ) (format "~a | ~a" (~a e #:max-width 20) (ctx->ctxi κ)))
    ((ko v ι κ) (format "~a | ~a" (~a v #:max-width 20) (ctx->ctxi κ)))))

(define (state-κ s)
  (match s
    ((ev _ _ _ κ) κ)
    ((ko _ _ κ) κ)))

(define (call-state-analysis sys)
  (let* ((graph (system-graph sys))
         (σ (system-σ sys))
         (Ξ (system-Ξ sys))
         (γ (lattice-γ (system-lattice sys))))

    (for/fold ((call-states (hash))) (((s ts) graph))
      (match s
        ((ev (? «app»? e) ρ ι κ)
         (for/fold ((call-states call-states)) ((t ts))
           (match t
             ((transition (ev _ _ '() κ*) _)
              (let* ((A-existing (hash-ref call-states κ* (set)))
                     (A-updated (set-union A-existing (reachable (s-referenced s Ξ) σ γ))))
                (hash-set call-states κ* A-updated)))
             (_ call-states))))
        (_ call-states)))))

(define GENERATES "GEN")
(define OBSERVES "OBS")

(define (generates-address-analysis sys)
  (let* ((call-states (call-state-analysis sys))
         (graph (system-graph sys))
         (σ (system-σ sys))
         (Ξ (system-Ξ sys))
         (γ (lattice-γ (system-lattice sys))))

    (define (handle a F s)
      (for/fold ((F F)) ((κ (stack-contexts (state-κ s) Ξ)))
        (let ((A (hash-ref call-states κ)))
          (if (set-member? A a)
              (let ((λ (ctx-λ κ)))
                (hash-set F λ (set-add (hash-ref F λ (set)) GENERATES)))
              F))))
    
    (for/fold ((F (hash))) (((s ts) graph))
        (for/fold ((F F)) ((t ts))
          (match t
            ((transition _ E)
             (for/fold ((F F)) ((eff E))
               (match eff
                 ((wv a _)
                  (handle a F s))
                 ((wp a _ _)
                  (handle a F s))
                 (_ F)))))))))

(define (observes-address-analysis sys)
  (let* ((call-states (call-state-analysis sys))
         (graph (system-graph sys))
         (σ (system-σ sys))
         (Ξ (system-Ξ sys))
         (initial (system-initial sys)))

    (define (add-read-dep a λ R)
      (hash-set R a (set-add (hash-ref R a (set)) λ)))

    (define (add-observer λ F)
      (hash-set F λ (set-add (hash-ref F λ (set)) OBSERVES)))

    (define (add-observers a F O)
      (let ((λ-os (hash-ref O a (set))))
        (for/fold ((F F)) ((λ-o λ-os))
          (add-observer λ-o F))))
           
    (define (handle-w a R O)
      (let ((λ-rs (hash-ref R a (set))))
        (for/fold ((O O)) ((λ-r λ-rs))
          (hash-set O a (set-add (hash-ref O a (set)) λ-r)))))

    (define (handle-r a F R O s)
      (for/fold ((F F) (R R)) ((κ (stack-contexts (state-κ s) Ξ)))
        (let ((A (hash-ref call-states κ)))
          (if (set-member? A a)
              (let ((λ (ctx-λ κ)))
                (values (add-observers a F O)
                        (add-read-dep a λ R)))
                (values F R)))))

    (define (handle-wv a R O)
      (handle-w a R O))

    (define (handle-wp a n R O)
      (handle-w (cons a n) R O))
    
    (define (handle-rv a F R O s)
      (handle-r a F R O s))

    (define (handle-rp a n F R O s)
      (handle-r (cons a n) F R O s))

    (define (traverse-graph S W F R O)
      (if (set-empty? W)
          F
          (let ((s (set-first W)))
            (if (set-member? S s)
                (traverse-graph S (set-rest W) F R O)
                (let-values (((W* F* R* O*)
                              (for/fold ((W W) (F F) (R R) (O O)) ((t (hash-ref graph s (set))))
                                (match t
                                  ((transition s* E)
                                   (let ((W (set-add (set-remove W s) s*)))
                                     (for/fold ((W W) (F F) (R R) (O O)) ((eff E))
                                       (match eff
                                         ((wv a _)
                                          (let ((O (handle-wv a R O)))
                                            (values W F R O)))
                                         ((wp a n _)
                                          (let ((O (handle-wp a n R O)))
                                            (values W F R O)))
                                         ((rv a _)
                                        (let-values (((F R) (handle-rv a F R O s)))
                                          (values W F R O)))
                                         ((rp a n _)
                                        (let-values (((F R) (handle-rp a n F R O s)))
                                          (values W F R O)))
                                       (_ (values W F R O))))))))))
                  (let* ((unchanged (and (equal? F F*) (equal? R R*) (equal? O O*)))
                         (S* (if unchanged (set-add S s) (set))))
                    (traverse-graph S* W* F* R* O*)))))))

    (traverse-graph (set) (set initial) (hash) (hash) (hash))))

(define (address-purity-analysis sys)
  (let ((F-gen (generates-address-analysis sys))
        (F-obs (observes-address-analysis sys)))
    (hash-⊔ F-gen F-obs set-union (set))))

(define PURE "PURE")
(define OBSERVER "OBS")
(define PROCEDURE "PROC")

(define (extend-to-applied F Ξ)
  (for/hash ((κ (hash-keys Ξ)))
    (let ((λ (ctx-λ κ)))
      (values λ (hash-ref F λ (set))))))

(define (F->C F)
  (for/hash (((λ f) F))
    (cond
      ((set-empty? f) (values λ PURE))
      ((set-member? f GENERATES) (values λ PROCEDURE))
      (else (values λ OBSERVES)))))

(define (print-purity-info C)
  (for (((λ c) C))
    (printf "~a -> ~a\n" (~a λ #:max-width 30) c)))


#|                                     
(define THROW (make-parameter #t))

(struct benchmark-config (name mach handler))
(define conc-config (benchmark-config "CONC" (make-machine conc-lattice conc-alloc)
                                    (make-address-handler #f)))
(define fa-config (benchmark-config "FA" (make-machine type-lattice mono-alloc)
                                    (make-address-handler #f)))

(define PRINT-PER-LAMBDA (make-parameter #t))

(define (test . ens)  
  (when (null? ens)
    (set! ens '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat collatz rsa primtest factor)))
  (printf "Benchmarks: ~a\n" ens)
  (define configs (list conc-config fa-config))
  (printf "Configs: ~a\n" configs)
  (parameterize ((PRINT-PER-LAMBDA #f))
    (for/list ((en ens))
      (cons en
            (for/list ((config configs))
              (let ((e (eval en)))
                (printf "~a" (~a en #:min-width 15))
                (cons (benchmark-config-name config) (purity e config))))))))

(define (server-test)
  (parameterize ((CESK-TIMELIMIT 60) (THROW #f))
    (let ((results (apply test '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat collatz rsa primtest factor
                                     nqueens dderiv destruct mceval
                                     ; regex boyer 
                                     )))) 
      (printf "Done.")
      results)))


(struct benchmark (state-count duration exit msg num-lambdas num-called num-pure num-obs num-proc))

(define (purity e config)
  (printf "~a" (~a (benchmark-config-name config) #:min-width 5 #:max-width 5))
  (let* ((mach (benchmark-config-mach config))
         (handler (benchmark-config-handler config))
         (bench (benchmark-eval e mach handler))
         (exit (benchmark-exit bench))
         (msg (benchmark-msg bench))
         (state-count (benchmark-state-count bench))
         (duration (benchmark-duration bench)))
    (printf "#~a flow-time ~a lams ~a called ~a pure ~a obs ~a proc ~a | ~a\n"
            (~a (if (eq? exit 'ok) state-count (format ">~a" state-count)) #:min-width 7)
            (~a duration #:min-width 7)
            (~a (benchmark-num-lambdas bench) #:min-width 3)
            (~a (benchmark-num-called bench) #:min-width 3)
            (~a (benchmark-num-pure bench) #:min-width 2)
            (~a (benchmark-num-obs bench) #:min-width 2)
            (~a (benchmark-num-proc bench) #:min-width 2)
            (~a msg #:max-width 72))
    bench))

(define (benchmark-eval e mach handler)
  (define (nodes ast) (for/fold ((cs (list ast))) ((c (children ast))) (append cs (nodes c))))
  (define (lambdas ast) (filter «lam»? (nodes ast)))
  (with-handlers ((exn:fail? (lambda (exc) (if (THROW) (raise exc) (benchmark -1 -1 'error exc 0 0 0 0 0)))))
    (let* ((sys (mach e))
           (flow-duration (system-duration sys))
           (flow-state-count (vector-length (system-states sys)))
           (flow-exit (system-exit sys))
           (msg (if (eq? flow-exit 'ok) (answer-value sys) (system-msg sys))))
      (if (eq? flow-exit 'ok)
          (let* ((initial (system-initial sys))
                 (ast (ev-e initial))
                 (num-lambdas (length (lambdas ast)))
                 (Ξ (system-Ξ sys))
                 (C (purity-analysis sys (handler sys)))
                 (Cpop (go->pop C))
                 (num-called (set-count (list->set (map (lambda (κ) (ctx-λ κ)) (hash-keys Ξ))))))
            (let-values (((num-pure num-obs num-proc) (for/fold ((num-pure 0) (num-obs 0) (num-proc 0)) (((λ c) Cpop))
                                                          (when (PRINT-PER-LAMBDA)
                                                            (printf "~a -> ~a\n" (~a λ #:max-width 30) c))
                                                          (cond
                                                            ((eq? c "PURE") (values (add1 num-pure) num-obs num-proc))
                                                            ((eq? c "PROC") (values num-pure num-obs (add1 num-proc)))
                                                            ((eq? c "OBS") (values num-pure (add1 num-obs) num-proc))
                                                            (else (raise c))))))
              (benchmark flow-state-count flow-duration flow-exit msg num-lambdas num-called num-pure num-obs num-proc)))
          (benchmark flow-state-count flow-duration flow-exit msg 0 0 0 0 0)))))


;; Lower-bound for printing time (if smaller, prints \epsilon), in seconds
(define TIMECUTOFF (make-parameter 1))
(define TIMEFORMAT (make-parameter
                    ;; Round to seconds by default: 1
                    (lambda (time) (format "~a''" (inexact->exact (round time))))
                    ;; Other possibility: 1.234''
                    ;; (lambda (n) (~a time "''"))
                    ))
(define (display-size-tex result)
  (define (to-states benchmark)
    (~a (if (eq? (benchmark-exit benchmark) 'user) "$>$" "") (benchmark-state-count benchmark)))
  
  (printf "\\begin{tabular}{lllll} Program & Variance & Base & Summarizing & Self-adjusting \\\\ \\hline \n")
  (for/list ((res result))
    (match res
      ((list res-0 res-0-summ res-0-sa res-1 res-1-summ res-1-sa)
       ;; 0-CFA
       (printf "\\code{~a}      & 0CFA         & ~a   & ~a     & ~a          \\\\"
               (~a "benchmark-name res-0") 
               (~a (to-states res-0))      
               (~a (to-states res-0-summ))
               (~a (to-states res-0-sa))
               )
       ;; 1-CFA
       (printf "                & 1CFA         & ~a   & ~a    & ~a          \\\\[6pt]\n"
               (~a (to-states res-1))
               (~a (to-states res-1-summ))
               (~a (to-states res-1-sa)) 
               ))))
  (printf "\\end{tabular}\n"))

(define (display-time-tex result)
  (define (to-time benchmark)
    (if (eq? (benchmark-exit benchmark) 'user)
        "$\\infty$"
        (let ((duration (benchmark-duration benchmark)))
          (if (< duration 1000)
              "$\\epsilon$" 
              (format "~a''" (inexact->exact (round (/ duration 1000))))))))
  
  (printf "\\begin{tabular}{lllll} Program & Variance & Base & Summarizing & Self-adjusting \\\\ \\hline \n")
  (for/list ((res result))
    (match res
      ((list res-0 res-0-summ res-0-sa res-1 res-1-summ res-1-sa)
       ;; 0-CFA
       (printf "\\code{~a}      & 0CFA         & ~a   & ~a      & ~a          \\\\"
               (~a "benchmark-name res-0") 
               (~a (to-time res-0))      
               (~a (to-time res-0-summ))
               (~a (to-time res-0-sa)))
       ;; 1-CFA
       (printf "                & 1CFA         & ~a   & ~a      & ~a          \\\\[6pt]\n"
               (~a (to-time res-1))
               (~a (to-time res-1-summ))
               (~a (to-time res-1-sa))))))
  (printf "\\end{tabular}\n"))


(define (mark-proc C λ)
  (hash-set C λ (set-add (hash-ref C λ) "GEN")))

(define (mark-obs C λ)
  (hash-set C λ (set-add (hash-ref C λ) "OBS")))

(define (add-read-dep R a decl λ)
  (let* ((key (cons a decl))
         (current-deps (hash-ref R key (set))))
    (if (set-member? current-deps λ)
        R
        (hash-set R key (set-add current-deps λ)))))

(define (add-potential-obs O a decl λ)
  (let* ((key (cons a decl))
         (current-os (hash-ref O key (set))))
    (if (set-member? current-os λ)
        O
        (hash-set O key (set-add current-os λ)))))

; ADDRESS
(define (handle-wv-address a x ctxs ctx-λ ctx-Aσ C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (Aσ (ctx-Aσ τ)))
          (if (member a Aσ)
              (let* ((λ (ctx-λ τ))
                     (C* (mark-proc C λ)))
                (stack-walk (set-rest ctxs) C*))
              (stack-walk (set-rest ctxs) C))))))
(define (handle-wp-address a n x ctxs ctx-λ ctx-Aσ C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (Aσ (ctx-Aσ τ)))
          (if (member a Aσ)
              (let* ((λ (ctx-λ τ))
                     (C* (mark-proc C λ)))
                (stack-walk (set-rest ctxs) C*))
              (stack-walk (set-rest ctxs) C))))))
(define (handle-rv-address a x ctxs ctx-λ ctx-Aσ ast C R O)
  (let ((decl (get-declaration («id»-x x) x ast)))
    (let stack-walk ((ctxs ctxs) (C C) (R R))
      (if (set-empty? ctxs)
          (values C R O)
          (let* ((τ (set-first ctxs))
                 (Aσ (ctx-Aσ τ)))
            (if (member a Aσ)
                (let* ((λ (ctx-λ τ))
                       (R* (add-read-dep R a decl λ))
                       (potential-o (hash-ref O (cons a decl) (set)))
                       (C* (if (set-member? potential-o λ)
                               (mark-obs C λ)
                               C)))
                  (stack-walk (set-rest ctxs) C* R*))
                (stack-walk (set-rest ctxs) C R)))))))
(define (handle-rp-address a n x ctxs ctx-λ ctx-Aσ C R O)
  (let stack-walk ((ctxs ctxs) (C C) (R R))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (Aσ (ctx-Aσ τ)))
          (if (member a Aσ)
              (let* ((λ (ctx-λ τ))
                     (R* (add-read-dep R a n λ))
                     (potential-o (hash-ref O (cons a n) (set)))
                     (C* (if (set-member? potential-o λ)
                             (mark-obs C λ)
                             C)))
                (stack-walk (set-rest ctxs) C* R*))
              (stack-walk (set-rest ctxs) C R))))))

; V SCOPE
(define (handle-wv-scope x ctxs ctx-λ ast C R O)
  (let ((decl (get-declaration («id»-x x) x ast)))
    (let stack-walk ((ctxs ctxs) (C C))
      (if (set-empty? ctxs)
          (values C R O)
          (let* ((τ (set-first ctxs))
                 (λ (ctx-λ τ)))
            (if (outer-scope-declaration? decl λ ast)
                (let ((C* (mark-proc C λ)))
                  (stack-walk (set-rest ctxs) C*))
                (stack-walk (set-rest ctxs) C)))))))
(define (handle-rv-scope a x ctxs ctx-λ ast C R O)
  (let ((decl (get-declaration («id»-x x) x ast)))
    (let stack-walk ((ctxs ctxs) (C C) (R R))
      (if (set-empty? ctxs)
          (values C R O)
          (let* ((τ (set-first ctxs))
                 (λ (ctx-λ τ)))
            (if (inner-scope-declaration? decl λ)
                (stack-walk (set-rest ctxs) C R)
                (if (outer-scope-declaration? decl λ ast)
                    (let* ((R* (add-read-dep R a decl λ))
                           (potential-o (hash-ref O (cons a decl) (set)))
                           (C* (if (set-member? potential-o λ)
                                   (mark-obs C λ)
                                   C)))
                      (stack-walk (set-rest ctxs) C* R*))
                    (stack-walk (set-rest ctxs) C R))))))))
; P FRESH
(define (handle-wp-fresh x ctxs ctx-λ Fκ ast C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((κ (set-first ctxs))
               (fresh (hash-ref Fκ κ (set))))
          (if (fresh? x fresh ast)
              (stack-walk (set-rest ctxs) C)
              (let* ((λ (ctx-λ κ))
                     (C* (mark-proc C λ)))
                (stack-walk (set-rest ctxs) C*)))))))
(define (handle-rp-fresh a n x ctxs ctx-λ Fκ ast C R O)
  (let stack-walk ((ctxs ctxs) (C C) (R R))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((κ (set-first ctxs))
               (fresh (hash-ref Fκ κ (set))))
          (if (fresh? x fresh ast)
              (stack-walk (set-rest ctxs) C R)
              (let* ((λ (ctx-λ κ))
                     (R* (add-read-dep R a n λ))
                     (potential-o (hash-ref O (cons a n) (set)))
                     (C* (if (set-member? potential-o λ)
                             (mark-obs C λ)
                             C)))
                (stack-walk (set-rest ctxs) C* R*)))))))

; FALLBACK
(define (handle-w ctxs ctx-λ C R O)
  (let stack-walk ((ctxs ctxs) (C C))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (λ (ctx-λ τ))
               (C* (mark-proc C λ)))
          (stack-walk (set-rest ctxs) C*)))))

(define (handle-r a n ctxs ctx-λ C R O)
  (let stack-walk ((ctxs ctxs) (C C) (R R))
    (if (set-empty? ctxs)
        (values C R O)
        (let* ((τ (set-first ctxs))
               (λ (ctx-λ τ))
               (R* (add-read-dep R a n λ))
               (potential-o (hash-ref O (cons a n) (set)))
               (C* (if (set-member? potential-o λ)
                       (mark-obs C λ)
                       C)))
          (stack-walk (set-rest ctxs) C* R*)))))

(define (make-address-handler ctx-Aσ)
  (lambda (sys)
    (lambda (effect state ast Ξ ctx-λ C R O)
      (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
             (ctxs (stack-contexts κ Ξ)))
        (match effect
          ((wv a x)
           (let* ((decl (get-declaration («id»-x x) x ast))
                  (r-deps (hash-ref R (cons a decl) (set)))
                  (O* (let update-o ((O O) (r-deps r-deps))
                        (if (set-empty? r-deps)
                            O
                            (let* ((r-dep (set-first r-deps))
                                   (O* (add-potential-obs O a decl r-dep)))
                              (update-o O* (set-rest r-deps)))))))
             (handle-wv-address a x ctxs ctx-λ ctx-Aσ C R O)))
          ((wp a n x)
           (let* ((r-deps (hash-ref R (cons a n) (set)))
                  (O* (let update-o ((O O) (r-deps r-deps))
                        (if (set-empty? r-deps)
                            O
                            (let* ((r-dep (set-first r-deps))
                                   (O* (add-potential-obs O a n r-dep)))
                              (update-o O* (set-rest r-deps)))))))
             (handle-wp-address a n x ctxs ctx-λ ctx-Aσ C R O*)))
          ((rv a x)
           (handle-rv-address a x ctxs ctx-λ ctx-Aσ ast C R O))
          ((rp a n x)
           (handle-rp-address a n x ctxs ctx-λ ctx-Aσ C R O))
          (_ (values C R O)))))))

(define (make-non-address-handler)
  (lambda (sys)
    (let ((Fς (fresh-analysis sys)))
      (lambda (effect state ast Ξ ctx-λ C R O)
        (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
               (ctxs (stack-contexts κ Ξ)))
          (match effect
            ((wv a x)
             (let* ((decl (get-declaration («id»-x x) x ast))
                    (r-deps (hash-ref R (cons a decl) (set)))
                    (O* (let update-o ((O O) (r-deps r-deps))
                          (if (set-empty? r-deps)
                              O
                              (let* ((r-dep (set-first r-deps))
                                     (O* (add-potential-obs O a decl r-dep)))
                                (update-o O* (set-rest r-deps)))))))
               (handle-wv-scope x ctxs ctx-λ ast C R O*)))
            ((wp a n x)
             (let* ((r-deps (hash-ref R (cons a n) (set)))
                    (O* (let update-o ((O O) (r-deps r-deps))
                          (if (set-empty? r-deps)
                              O
                              (let* ((r-dep (set-first r-deps))
                                     (O* (add-potential-obs O a n r-dep)))
                                (update-o O* (set-rest r-deps)))))))
               (handle-wp-fresh x ctxs ctx-λ (hash-ref Fς state) ast C R O)))
            ((rv a x)
             (handle-rv-scope a x ctxs ctx-λ ast C R O))
            ((rp a n x)
             (handle-rp-fresh a n x ctxs ctx-λ (hash-ref Fς state) ast C R O))
            (_ (values C R O))))))))


|#

(define (generate-dot sys name)
  
  (let* ((graph (system-graph sys))
         (states (system-states sys))
         (dotf (open-output-file (format "~a.dot" name) #:exists 'replace)))
    (fprintf dotf "digraph G {\n")
    (for ((i (vector-length states)))
      (let ((s (vector-ref states i)))
        (fprintf dotf "~a [label=\"~a | ~a\"];\n" i i (state-repr s))))
    (hash-for-each graph (lambda (s ts)
                           (let ((i1 (vector-member s states))
                                 (is (set-map ts (lambda (t) (vector-member (transition-s t) states)))))
                             (for-each (lambda (i2)
                                         (fprintf dotf "~a -> ~a;\n" i1 i2)) is))))
    (fprintf dotf "}")
    (close-output-port dotf))
  
  sys)
