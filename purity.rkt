#lang racket

(random-seed 111) ; deterministic random
(define TIMELIMIT (make-parameter 2)) ; timeout in minutes
(define STATELIMIT (make-parameter 999999)) ; state limit (NOT YET IMPLEMENTED)
(define THROW (make-parameter #t)) ; let exceptions bubble up (#t) during benchmarking, or catch and log them (#f)

(define %random (lambda (n) (if (zero? n) 0 (random n))))

(include "general.rkt")
(include "ast.rkt")

(define (index v x)
  (let ((i (vector-member x v)))
    (if i
        i
        (let ((i (add1 (vector-ref v 0))))
          (vector-set! v 0 i)
          (vector-set! v i x)
          i))))
;(define frameis (make-vector 1000))
;(define (frame->framei frame) (index frameis frame))
(define ctxis (make-vector 1000))
(define (ctx->ctxi ctx) (index ctxis ctx))
;(define stateis (make-vector 1000))
;(define (state->statei q) (index stateis q))
;(define storeis (make-vector 1000))
;(define (store->storei σ) (index storeis σ))

;; domain helpers
(define (env-lookup ρ x)
  (hash-ref ρ x))
(define (env-addresses ρ)
  (list->set (hash-values ρ)))
(define (store-lookup σ a)
  (hash-ref σ a))
(define (store-⊒ σ1 σ2 ⊒)
  (if (eq? σ1 σ2)
      #t
      (if (< (hash-count σ1) (hash-count σ2))
          #f
          (for/and (((k v) σ1))
            (and (hash-has-key? σ2)
                 (⊒ v (hash-ref σ2 k)))))))
(define (stack-lookup Ξ τ)
  (hash-ref Ξ τ))
;;

;; machine
(struct ev (e ρ σ ι κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "EV ~a\nρ ~a\nσ ~a\nι ~a\nκ ~a" (ev-e v) (ev-ρ v) (ev-σ v) (ev-ι v) (ev-κ v))))
(struct ko (ι κ v σ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "KO ι ~a\nκ ~a\nv ~a\nσ ~a" (ko-ι v) (ko-κ v) (ko-v v) (ko-σ v))))
(struct ctx (e clo vs σ A) #:transparent)
(struct letk (x e ρ) #:transparent)
(struct letreck (a e ρ) #:transparent)
(struct haltk () #:transparent)
(struct clo (λ ρ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<clo ~a>" («lam»-l (clo-λ v)))))
(struct prim (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                        (equal? (prim-name s1) (prim-name s2))))
                                                   (define hash-proc (lambda (s rhash) (equal-hash-code (prim-name s))))
                                                   (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim-name s))))))
(struct prim2 (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                         (equal? (prim2-name s1) (prim2-name s2))))
                                                    (define hash-proc (lambda (s rhash) (equal-hash-code (prim2-name s))))
                                                    (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim2-name s))))))
(struct addr (a) #:transparent)
(struct system (states duration initial graph Ξ ⊥ ⊔ answer? exit msg) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<sys #~a ~a ~a>" (vector-length (system-states v)) (system-exit v) (~a (system-msg v) #:max-width 70))))

(struct wv (a x) #:transparent)
(struct rv (a x) #:transparent)
(struct wp (a n x) #:transparent)
(struct rp (a n x) #:transparent)
(struct fr () #:transparent)


(define (touches d)
  (if (set? d)
      (for/fold ((as (set))) ((v d)) (set-union as (touches v)))
      (match d
        ((clo _ ρ) (env-addresses ρ))
        ((letk _ _ ρ) (env-addresses ρ))
        ((letreck _ _ ρ) (env-addresses ρ))
        ((addr a) (set a))
        ((cons x y) (set-union (touches x) (touches y)))
        (_ (set)))))
(define (reachable A σ γ)
  (let loop ((A A) (R (set)))
    (if (set-empty? A)
        R
        (let ((a (set-first A)))
          (if (set-member? R a)
              (loop (set-rest A) R)
              (let* ((v (γ (store-lookup σ a)))
                     (T (touches v)))
                (loop (set-union (set-rest A) T) (set-add R a))))))))
(define (gc q Ξ γ)
  (match q
    ((ev e ρ σ ι κ)
     (let* ((ρ* (↓ ρ (free e)))
            (R (reachable (set-union (env-addresses ρ*) (stack-addresses ι κ)) σ γ))
            (σ* (↓ σ R)))
       (ev e ρ* σ* ι κ)))
    ((ko ι κ v σ)
     (let* ((R (reachable (set-union (touches v) (stack-addresses ι κ)) σ γ))
            (σ* (↓ σ R)))
       (ko ι κ v σ*)))))
(define (stack-frames ι κ Ξ)
  (let loop ((todo (set (cons ι κ))) (result (set)) (seen (set)))
    (if (set-empty? todo)
        result
        (match-let (((cons ι κ) (set-first todo)))
          (let* ((result* (set-union result (list->set ι))))
            (if (or (not κ) (set-member? seen κ))
                (loop (set-rest todo) result* seen)
                (let ((ικs (stack-lookup Ξ κ)))
                  (loop (set-union (set-rest todo) ικs) result* (set-add seen κ)))))))))
(define (stack-pop ι κ Ξ G)
  (if (null? ι)
      (if (set-member? G κ)
          (set)
          (let ((ικs (stack-lookup Ξ κ)))
            (apply set-union (set-map ικs (lambda (ικ) (stack-pop (car ικ) (cdr ικ) Ξ (set-add G κ)))))))
      (set (list ι κ G)))) 
(define (stack-contexts κ Ξ)
  (let loop ((todo (set (cons #f κ))) (seen (set)))
    (if (set-empty? todo)
        seen
        (let ((κ (cdr (set-first todo))))
          (if (or (not κ) (set-member? seen κ))
              (loop (set-rest todo) seen)
              (loop (set-union (set-rest todo) (stack-lookup Ξ κ)) (set-add seen κ)))))))
(define (stack-addresses ι κ)
  (set-union (if (null? ι) (set) (apply set-union (map touches ι))) (if κ (ctx-A κ) (set))))

(define (make-machine global α γ ⊥ ⊔ alloc store-update true? false? α-eq?)
  
  (define (explore e)
    (define Ξ (make-hash))
    (define Ξi 0)
    
    (include "primitives.rkt")
    
    (define (inject e)
      (let ((global* (append global
                             `(("eq?" . ,(α (prim "eq?" prim-eq?)))
                               ("~a" . ,(α (prim "~a" prim-to-string)))
                               ("error" . ,(α (prim "error" prim-error)))
                               ("pair?" . ,(α (prim "pair?" prim-pair)))
                               ("cons" . ,(α (prim "cons" prim-cons)))
                               ("car" . ,(α (prim "car" prim-car)))
                               ("set-car!" . ,(α (prim "set-car!" prim-set-car!)))
                               ("cdr" . ,(α (prim "cdr" prim-cdr)))
                               ("set-cdr!" . ,(α (prim "set-cdr!" prim-set-cdr!))))))
            (compiled-e (compile e)))
        (set! conc-alloc-counter 0)
        (let loop ((global global*) (ρ (hash)) (σ (hash)))
          (match global
            ('()
             (gc (ev compiled-e (↓ ρ (free compiled-e)) σ `(,(haltk)) #f) (hash) γ))
            ((cons (cons x v) r)
             (let ((a (conc-alloc x 0)))
               (loop r (hash-set ρ x a) (hash-set σ a v))))))))
    
    ;(define (stack-to-string stack)
    ;  (cons (map frame->framei (car stack)) (ctx->ctxi (cdr stack))))
    
    (define (env-bind ρ x a)
      (hash-set ρ x a))
    
    (define (store-alloc σ a v)
      (let ((current (hash-ref σ a ⊥)))
        (hash-set σ a (⊔ current v))))
    
    (define (stack-alloc! τ stack)
      ;(printf "allocing ctx ~a stack ~a " (ctx->ctxi τ) (stack-to-string stack))
      (let ((stacks (hash-ref Ξ τ #f)))
        (if stacks
            (unless (set-member? stacks stack)
              ;(printf "ADDING to ~a\n" (set-map stacks stack-to-string))
              (hash-set! Ξ τ (set-add stacks stack))
              (set! Ξi (add1 Ξi)))
            (begin
              ;(printf "NEW CTX\n")
              (hash-set! Ξ τ (set stack))
              (set! Ξi (add1 Ξi))))))
    
    (define (alloc-literal e σ)
      (if (pair? e)
          (match-let (((cons car-v car-σ) (alloc-literal (car e) σ)))
            (match-let (((cons cdr-v cdr-σ) (alloc-literal (cdr e) car-σ)))
              (let ((a (alloc "%$lit" e)))
                (cons (α (addr a)) (store-alloc cdr-σ a (α (cons car-v cdr-v)))))))
          (cons (α e) σ)))
    
    (define (eval-atom ae ρ σ)
      (match ae
        ((«lit» _ v)
         (values (α v) (set)))
        ((«id» _ x)
         (let ((a (env-lookup ρ x)))
           (values (store-lookup σ a) (set (rv a ae)))))
        ((«lam» _ x e)
         (let ((cl (clo ae ρ)))
           (values (α cl) (set))))
        ((«quo» _ atom)
         (values (α atom) (set)))
        (_ (error "cannot handle ae" ae))))
    
    (define (apply-let-kont x e ρ ι κ v σ E)
      (let* ((a (alloc x (and κ (ctx-e κ))))
             (ρ* (env-bind ρ («id»-x x) a))
             (σ* (store-alloc σ a v)))
        (set (cons (ev e ρ* σ* ι κ) E))))
    (define (apply-letrec-kont x e ρ ι κ v σ E)
      (let* ((a (env-lookup ρ («id»-x x)))
             (σ* (store-update σ a v)))
        (set (cons (ev e ρ σ* ι κ) E))))
    (define (apply-local-kont ι κ v σ E)
      (match ι
        ((cons (letk x e ρ) ι)
         (apply-let-kont x e ρ ι κ v σ E))
        ((cons (letreck x e ρ) ι)
         (apply-letrec-kont x e ρ ι κ v σ E))
        (_ (set (cons (ko ι κ v σ) E)))))
    
    ;(define (print-state q)
    ;  (match q
    ;   ((ev e ρ σ ι κ m) (printf "EV ~a\nρ ~a σ ~a\nι ~a κ ~a frames ~a\n" (~a e #:max-width 40) ρ (store->storei σ) (map frame->framei ι) (ctx->ctxi κ) (set-map (stack-frames ι κ Ξ) frame->framei)))
    ;    ((ko ι κ v σ m) (printf "KO ~a σ ~a\nι ~a κ ~a frames ~a\n" v (store->storei σ) (map frame->framei ι) (ctx->ctxi κ) (set-map (stack-frames ι κ Ξ) frame->framei)))))
    
    (define (step q)
      ;(check-safety q Ξ)
      (match q
        ((ev (? ae? ae) ρ σ ι κ)
         (let-values (((v E) (eval-atom ae ρ σ)))
           (set (cons (ko ι κ v σ) E))))
        ((ev («if» _ ae e1 e2) ρ σ ι κ)
         (let-values (((v E) (eval-atom ae ρ σ)))
           (set-union (if (true? v)
                          (if (ae? e1)
                              (let-values (((v* E*) (eval-atom e1 ρ σ)))
                                (set (cons (ko ι κ v* σ) (set-union E E*))))
                              (set (cons (ev e1 ρ σ ι κ) E)))
                          (set))
                      (if (false? v)
                          (if (ae? e2)
                              (let-values (((v* E*) (eval-atom e2 ρ σ)))
                                (set (cons (ko ι κ v* σ) (set-union E E*))))
                              (set (cons (ev e2 ρ σ ι κ) E)))
                          (set)))))
        ((ev («let» _ x e0 e1) ρ σ ι κ)
          (if (ae? e0)
              (let-values  (((v E) (eval-atom e0 ρ σ)))
                (apply-let-kont x e1 ρ ι κ v σ E))
              (set (cons (ev e0 ρ σ (cons (letk x e1 ρ) ι) κ) (set)))))
        ((ev («letrec» _ x e0 e1) ρ σ ι κ)
         (let* ((a (alloc x (and κ (ctx-e κ))))
                (ρ* (env-bind ρ («id»-x x) a))
                (σ* (store-alloc σ a ⊥)))
           (if (ae? e0)
               (let-values (((v E) (eval-atom e0 ρ* σ*)))
                 (apply-letrec-kont x e1 ρ* ι κ v σ* E))
               (set (cons (ev e0 ρ* σ* (cons (letreck a e1 ρ*) ι) κ) (set))))))
        ((ev («set!» _ x ae) ρ σ ι κ)
         (let-values (((v E) (eval-atom ae ρ σ)))
           (let* ((a (env-lookup ρ («id»-x x)))
                  (σ* (store-update σ a v)))
             (set (cons (ko ι κ v σ*) (set-add E (wv a x)))))))
        ((ev («quo» _ e) ρ σ ι κ)
         (match-let (((cons v σ) (alloc-literal e σ)))
           (set (cons (ko ι κ v σ) (set)))))
        ((ev (and («app» _ rator rands) e) ρ σ ι κ)
         (let-values (((v E) (eval-atom rator ρ σ)))
           (let rands-loop ((rands rands) (rvs '()) (E E))
             (if (null? rands)
                 (for/fold ((succ (set))) ((w (γ v)))
                   (match w
                     ((clo («lam» _ x e0) ρ**)
                      (let* ((A (stack-addresses ι κ))
                             (τ (ctx e w rvs σ A)))
                        
                        (define (bind-loop x vs ρ* σ*)
                          (match x
                            ('()
                             (stack-alloc! τ (cons ι κ))
                             (set-add succ (cons (ev e0 ρ* σ* '() τ) E)))
                            ((cons x xs)
                             (if (null? vs)
                                 (set)
                                 (let ((a (alloc x e)))
                                   (bind-loop xs (cdr vs) (env-bind ρ* («id»-x x) a) (store-alloc σ* a (car vs))))))))
                        
                        (bind-loop x (reverse rvs) ρ** σ)))
                     ((prim _ proc)
                      (set-union succ (list->set (set-map (proc e (reverse rvs) σ ι κ Ξ) (lambda (vσE) (cons (ko ι κ (car vσE) (cadr vσE)) (set-union E (caddr vσE))))))))
                     ((prim2 _ proc)
                      (set-union succ (set (cons (ko ι κ (apply proc (reverse rvs)) σ) E))))
                     (_ (set))))
                 (let-values (((v E*) (eval-atom (car rands) ρ σ)))
                   (rands-loop (cdr rands) (cons v rvs) (set-union E E*)))))))
        ((ko (cons (haltk) _) #f v _)
         (set))
        ((ko ι κ v σ)
         (let* ((ικGs (stack-pop ι κ Ξ (set))))
           (let loop ((ικGs ικGs) (succ (set)))
             (if (set-empty? ικGs)
                 succ
                 (let* ((ικG (set-first ικGs))
                        (ι (car ικG))
                        (κ (cadr ικG))
                        (succ* (apply-local-kont ι κ v σ (set))))
                   (loop (set-rest ικGs)
                         (set-union succ succ*)))))))
        )) ; end step
    
    (define visited (mutable-set))
    (define graph (make-hash))
    (define states (mutable-set))
    (define initial (inject e))
    (define (make-system duration exit msg)
      (system (list->vector (set->list states)) duration initial graph Ξ ⊥ ⊔ answer? exit msg))
    
    ;(define state-limit (STATELIMIT))
    (define time-limit (+ (current-milliseconds) (* (TIMELIMIT) 60000)))
    
    (let ((start (current-milliseconds)))
      (with-handlers ((exn:fail? (lambda (exc) (make-system (- (current-milliseconds) start) 'error exc)))) 
        (let explore-loop ((todo (set initial)))
          (if (and (zero? (remainder (set-count states) 1000))
                   (> (current-milliseconds) time-limit))
              (make-system (- (current-milliseconds) start) 'user "time out")
              (if (set-empty? todo)
                  (make-system (- (current-milliseconds) start) 'ok "")
                  (let* ((q (set-first todo)))
                    (if (set-member? visited q)
                        (explore-loop (set-rest todo))
                        (let ((old-Ξi Ξi))
                          ;(printf "q ~a\n" (state->statei q))
                          (set-add! visited q)
                          (set-add! states q)
                          (let succ-loop ((succs (step q)) (new-states (set)) (succs-gc (set)))
                            (if (set-empty? succs)
                                (let* ((existing (hash-ref graph q (set)))
                                       (updated (set-union existing succs-gc)))
                                  (hash-set! graph q updated)
                                  (when (> Ξi old-Ξi)
                                    (set-clear! visited))
                                  (explore-loop (set-union new-states (set-rest todo))))
                                (let* ((succ (set-first succs))
                                       (q (car succ))
                                       (q-gc (gc q Ξ γ))
                                       (E (cdr succ)))
                                  (succ-loop (set-rest succs) (set-add new-states q-gc) (set-add succs-gc (cons q-gc E))))))))))))))
                          ) ; end explore  
  (define (answer? s)
    (match s
      ((ko (cons (haltk) _) _ v _) #t)
      (_ #f)))
  
  explore)

(define (answer-set sys)
  (let ((answer? (system-answer? sys)))
    (for/fold ((v (set))) ((s (system-states sys)))
      (if (answer? s)
          (set-add v s)
          v))))

(define (answer-value sys)
  (let* ((⊥ (system-⊥ sys))
         (⊔ (system-⊔ sys)))
    (for/fold ((v ⊥)) ((s (answer-set sys)))
      (⊔ (ko-v s) v))))
;;

;; allocators
(define conc-alloc-counter 0)
(define conc-alloc
  (lambda (_ __)
    (set! conc-alloc-counter (add1 conc-alloc-counter))
    conc-alloc-counter))

(define (mono-alloc x _)
  x)

(define (poly-alloc x ctx)
  (cons x ctx))
;  (cons x (if ctx
;              (clo-λ (ctx-clo ctx))
;              ctx)))
;;

;; Store updates
(define (weak-update σ a v)
  (hash-set σ a (type-⊔ (hash-ref σ a) v)))

(define (strong-update σ a v)
  (hash-set σ a v))

(include "lattice.rkt")
(include "test.rkt")

;; machines and evaluators
(define (do-eval e mach)
  (let ((sys (mach e)))
    (if (eq? (system-exit sys) 'ok)
        (answer-value sys)
        (raise (system-msg sys)))))

(define conc-mach (make-machine conc-global conc-α conc-γ conc-⊥ conc-⊔ conc-alloc strong-update conc-true? conc-false? conc-eq?))
(define type-mach-0 (make-machine type-global type-α type-γ type-⊥ type-⊔ mono-alloc weak-update type-true? type-false? type-eq?))
(define type-mach-1 (make-machine type-global type-α type-γ type-⊥ type-⊔ poly-alloc weak-update type-true? type-false? type-eq?))

(define (conc-eval e)
  (do-eval e conc-mach))
(define (type-eval-0 e)
  (do-eval e type-mach-0))
(define (type-eval-1 e)
  (do-eval e type-mach-1))
;;
(define (outer-scope-declaration? decl e ast)
  (let up ((e e))
    (let ((p (parent e ast)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? decl (car x))
                   #t
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? decl x)
                 #t
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? decl x)
             #t
             (up p)))
        (_ (up p))))))

(define (inner-scope-declaration? decl e)
  (or (eq? decl e)
      (for/or ((e* (children e)))
        (inner-scope-declaration? decl e*))))
    
(define (get-declaration name e ast)
  (let up ((e e))
    (let ((p (parent e ast)))
      (match p
        (#f #f)
        ((«lam» _ x _)
         (let right ((x x))
           (if (null? x)
               (up p)
               (if (equal? name («id»-x (car x)))
                   (car x)
                   (right (cdr x))))))
        ((«let» _ x e0 e1)
         (if (eq? e0 e)
             (up p)
             (if (equal? name («id»-x x))
                 x
                 (up p)))) 
        ((«letrec» _ x _ _)
         (if (equal? name («id»-x x))
             x
             (up p)))
        (_ (up p))))))

(define (fresh-analysis system)
  (let* ((graph (system-graph system))
         (Ξ (system-Ξ system))
         (initial (system-initial system))
         (ast (ev-e initial)))
    
    (define (handle-state state E fresh)
      (match state
        ((ev («set!» _ x ae) ρ σ ι κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (fresh? ae fresh ast)
               (set-add fresh decl)
               (set-remove fresh decl))))
        ((ev («let» _ x e0 e1) ρ σ ι κ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (fresh? e0 fresh ast)
               (set-add fresh decl)
               (set-remove fresh decl))))
        ((ko (cons (letk x e ρ) ι) κ v σ)
         (let ((decl (get-declaration («id»-x x) x ast)))
           (if (set-member? E (fr))
               (set-add fresh decl)
               ;(set-remove fresh decl)))) ; can never overrule ev let
               fresh)))
        (_ fresh)))
    
    (define (traverse S W Fκ Fς)
      (if (set-empty? W)
          Fς
          (let* ((sE (set-first W))
                 (state (car sE))
                 (E (cdr sE)))
            (if (set-member? S state)
                (traverse S (set-rest W) Fκ Fς)
                (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
                      (fresh (hash-ref Fκ κ (set)))
                      (fresh* (handle-state state E fresh))
                      (Fκ* (hash-set Fκ κ fresh*))
                      (Fς* (hash-set Fς state fresh*))
                      (ΔW (hash-ref graph state)))
                  (traverse (set-add S state) (set-union (set-rest W) ΔW) Fκ* Fς*))))))
    
    (traverse (set) (set (cons initial (set))) (hash) (hash))))


(define (fresh? e fresh ast)
  (match e
    ((«id» _ x)
     (let ((decl (get-declaration x e ast)))
       (set-member? fresh decl)))
    (_ #f)))
                 
  
(define (purity-analysis system)
  (let* ((graph (system-graph system))
         (Ξ (system-Ξ system))
         (initial (system-initial system))
         (ast (ev-e initial))
         (Fς (fresh-analysis system)))
    
    (define (traverse S W C R O P)
      (if (set-empty? W)
          C
          (let ((state (set-first W)))
            (if (set-member? S state)
                (traverse S (set-rest W) C R O P)
                (let ((update? #f))

                  ;(printf "\n\n~a\n" state)                
                  
                  (define (mark-proc C λ)
                    (let ((current-class (hash-ref C λ)))
                      (if (eq? current-class "PROC")
                          C
                          (begin
                            (set! update? #t)
                            (hash-set C λ "PROC")))))
                  
                  (define (mark-obs C λ)
                    (let ((current-class (hash-ref C λ)))
                      (if (or (eq? current-class "OBS") (eq? current-class "PROC"))
                          C
                          (begin
                            (set! update? #t)
                            (hash-set C λ "OBS")))))
                  
                  (define (add-read-dep R a decl λ)
                    (let* ((key (cons a decl))
                           (current-deps (hash-ref R key (set))))
                      (if (set-member? current-deps λ)
                          R
                          (begin
                            (set! update? #t)
                            (hash-set R key (set-add current-deps λ))))))
                  
                  (define (add-potential-obs O a decl λ)
                    (let* ((key (cons a decl))
                           (current-os (hash-ref O key (set))))
                      (if (set-member? current-os λ)
                          O
                          (begin
                            (set! update? #t)
                            (hash-set O key (set-add current-os λ))))))
                  
                  (define (handle-effect effect state ctxs C R O P)
                    (match effect
                      ((wv a x)
                       (let* ((decl (get-declaration («id»-x x) x ast))
                              (r-deps (hash-ref R (cons a decl) (set)))
                              (O* (let update-o ((O O) (r-deps r-deps))
                                    (if (set-empty? r-deps)
                                        O
                                        (let* ((r-dep (set-first r-deps))
                                               (O* (add-potential-obs O a decl r-dep)))
                                          (update-o O* (set-rest r-deps)))))))
                         (let stack-walk ((ctxs ctxs) (C C))
                           (if (set-empty? ctxs)
                               (values C R O* P)
                               (let* ((τ (set-first ctxs))
                                      (clo (ctx-clo τ))
                                      (λ (clo-λ clo)))
                                 (if (outer-scope-declaration? decl λ ast)
                                     (let ((C* (mark-proc C λ)))
                                       (stack-walk (set-rest ctxs) C*))
                                     (stack-walk (set-rest ctxs) C)))))))

                      ((wp a n x)
                       (let* ((r-deps (hash-ref R (cons a n) (set)))
                              (O* (let update-o ((O O) (r-deps r-deps))
                                    (if (set-empty? r-deps)
                                        O
                                        (let* ((r-dep (set-first r-deps))
                                               (O* (add-potential-obs O a n r-dep)))
                                          (update-o O* (set-rest r-deps)))))))
                         (if (fresh? x (hash-ref Fς state) ast)
                             (values C R O* P)
                             (let stack-walk ((ctxs ctxs) (C C))
                               (if (set-empty? ctxs)
                                   (values C R O* P)
                                   (let* ((τ (set-first ctxs))
                                          (Aσ (hash-keys (ctx-σ τ))))
                                     (if (member a Aσ)
                                         (let* ((clo (ctx-clo τ))
                                                (λ (clo-λ clo))
                                                (C* (mark-proc C λ)))
                                           (stack-walk (set-rest ctxs) C*))
                                         (stack-walk (set-rest ctxs) C))))))))
                      
                      ((rv a x)
                       (let ((decl (get-declaration («id»-x x) x ast)))
                         (let stack-walk ((ctxs ctxs) (C C) (R R))
                           (if (set-empty? ctxs)
                               (values C R O P)
                               (let* ((τ (set-first ctxs))
                                      (clo (ctx-clo τ))
                                      (λ (clo-λ clo)))
                                 (if (inner-scope-declaration? decl λ)
                                     (stack-walk (set-rest ctxs) C R)
                                     (if (outer-scope-declaration? decl λ ast)
                                         (let* ((R* (add-read-dep R a decl λ))
                                                (potential-o (hash-ref O (cons a decl) (set)))
                                                (C* (if (set-member? potential-o λ)
                                                        (mark-obs C λ)
                                                        C)))
                                           (stack-walk (set-rest ctxs) C* R*))
                                         (stack-walk (set-rest ctxs) C R))))))))
                      
                      ((rp a n x)
                       (let stack-walk ((ctxs ctxs) (C C) (R R))
                         (if (set-empty? ctxs)
                             (values C R O P)
                             (let* ((τ (set-first ctxs))
                                    (Aσ (hash-keys (ctx-σ τ))))
                               (if (member a Aσ)
                                   (let* ((clo (ctx-clo τ))
                                          (λ (clo-λ clo))
                                          (R* (add-read-dep R a n λ))
                                          (potential-o (hash-ref O (cons a n) (set)))
                                          (C* (if (set-member? potential-o λ)
                                                  (mark-obs C λ)
                                                  C)))
                                     (stack-walk (set-rest ctxs) C* R*))
                                   (stack-walk (set-rest ctxs) C R))))))
                      
                      (_ (values C R O P))))
                  
                  (let* ((κ (if (ev? state) (ev-κ state) (ko-κ state)))
                         (ctxs (stack-contexts κ Ξ)))
                    (let succ-loop ((succs (hash-ref graph state)) (ΔW (set)) (C C) (R R) (O O) (P P))
                      (if (set-empty? succs)
                          (traverse (if update? (set) (set-add S state)) (set-union (set-rest W) ΔW) C R O P)
                          (match-let (((cons s* E) (set-first succs)))
                            (let effect-loop ((E E) (C C) (R R) (O O) (P P))
                              (if (set-empty? E)
                                  (succ-loop (set-rest succs) (set-add ΔW s*) C R O P)
                                  (let-values (((C* R* O* P*) (handle-effect (set-first E) state ctxs C R O P)))
                                    (effect-loop (set-rest E) C* R* O* P*))))))))
                  ))))
      ); end traverse
    (let ((C
           (for/hash ((κ (hash-keys Ξ)))
             (let* ((clo (ctx-clo κ))
                    (λ (clo-λ clo)))
               (values λ "RT")))))
      (traverse (set) (set initial) C (hash) (hash) (hash)))))
;;


(define (memo-test . ens)
  
  (when (null? ens)
    (set! ens '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat ;'small' benchies
                          ;sat collatz rsa primtest factor
                          ))) 
  
  
  (printf "Warmup...\n\n")
  (type-mach-0 (file->value "test/fac.scm") )
  (type-mach-0 (file->value "test/eta.scm") )
  (type-mach-0 (file->value "test/rotate.scm"))
  (type-mach-0 (file->value "test/mj09.scm"))
  (type-mach-1 (file->value "test/loop2.scm"))
  (type-mach-1 (file->value "test/kcfa2.scm"))
  (type-mach-1 (file->value "test/fib.scm"))
  (type-mach-1 (file->value "test/kcfa3.scm"))
  
  (printf "Benchmarks: ~a\n" ens)
  (for/list ((en ens))
    (for/list ((mach (list type-mach-0 type-mach-1)))
      ;    (for/list ((mach (list conc-mach conc-mach-summ conc-mach-rt)))
      (let ((e (eval en)))
        (perform-benchmark en e mach)))))

(define server-results #f)
(define size-results #f)
(define time-results #f)
(define (server-test)
  (parameterize ((TIMELIMIT 30) (THROW #f))
    (let ((results (apply memo-test '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2
                                          sat collatz rsa primtest factor regex nqueens mceval boyer dderiv))))
      (set! server-results results)
      (set! size-results results)
      (set! time-results (filter (lambda (bench) (member (benchmark-name bench) '(sat collatz rsa primtest factor regex nqueens dderiv mceval boyer))) results))
      (printf "All results in server-results\nSize benchmarks in size-results\nTime benchmarks in time-results\n"))))

(define (purity-test)
  (define (test e expected)
    (let* ((C (purity-analysis (type-mach-0 e)))
           (C* (make-hash (hash-map C (lambda (k v) (cons («lam»-l k) v))))))
      (unless (equal? (make-hash expected) C*)
          (printf "error ~a\n~a ~a\n" e expected C*))))
  (test fac '((2 . "RT")))
  (test fib '((2 . "RT")))
  (test fib-mut '((2 . "RT") (12 . "PROC")))
  (test blur '((2 . "RT") (7 . "RT") (12 . "RT")))
  (test eta '((29 . "RT") (17 . "RT") (6 . "RT") (2 . "RT")))
  (test mj09 '((6 . "RT") (11 . "RT") (25 . "RT") (2 . "RT")))
  (test gcipd '((2 . "RT") (7 . "RT") (35 . "RT")))
  (test kcfa2 '((2 . "RT") (6 . "RT") (10 . "RT")))
  (test kcfa3 '((2 . "RT") (6 . "RT") (10 . "RT") (14 . "RT")))
  (test rotate '((2 . "RT")))
  (test loop2 '((2 . "RT") (16 . "RT") (57 . "RT")))
  (test '(let ((z #f)) (let ((f (lambda () (set! z #t)))) (f))) '((5 . "PROC")))
  (test '(let ((z #f)) (let ((h (lambda () (set! z #t)))) (let ((g (lambda () (h)))) (let ((f (lambda () (g)))) (f))))) '((5 . "PROC") (11 . "PROC") (16 . "PROC")))
  (test '(let ((z #f)) (let ((f (lambda () (let ((g (lambda () (let ((h (lambda () (set! z #t)))) (h))))) (g))))) (f))) '((5 . "PROC") (8 . "PROC") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((z #f)) (let ((g (lambda () (let ((h (lambda () (set! z #t)))) (h))))) (g)))))) (f)) '((2 . "RT") (8 . "PROC") (11 . "PROC")))
  (test '(letrec ((f (lambda () (let ((z #f)) (let ((g (lambda () (let ((u (set! z #t))) (f))))) (g)))))) (f)) '((2 . "RT") (8 . "PROC")))
  (test '(letrec ((f (lambda () (let ((z #f)) (let ((g (lambda () (set! z #t)))) (let ((u (g))) (f))))))) (f)) '((2 . "RT") (8 . "PROC")))
  (test '(let ((f (lambda (x) (let ((xx #f)) (let ((u (set! xx x))) xx))))) (let ((v (f 123))) (f v))) '((2 . "RT")))
  (test '(letrec ((f (lambda (n) (let ((m (- n 1))) (f m))))) (f 123)) '((2 . "RT")))
  (test '(letrec ((f (lambda (n) (let ((m (- n 1))) (let ((u (set! n m))) (f n)))))) (f 123)) '((2 . "RT")))
  (test '(letrec ((f (lambda (n) (let ((u (set! n 333))) (f n))))) (f 123)) '((2 . "RT")))
  (test '(letrec ((f (lambda (n) (let ((u (set! n 333))) (f n))))) (f 123)) '((2 . "RT")))
  (test '(let ((z #f)) (let ((f (lambda () z))) (let ((u (f))) (set! z #t)))) '((5 . "RT")))
  (test '(let ((z #f)) (let ((f (lambda () z))) (let ((u (f))) (let ((v (set! z #t))) (f))))) '((5 . "OBS")))
  (test '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((u (g))) (let ((v (set! x 5))) (g)))))))) (f)) '((2 . "RT") (8 . "OBS")))
  (test '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((uu x)) (let ((u (g))) (let ((v (set! x 5))) (g))))))))) (f)) '((2 . "RT") (8 . "OBS")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (set-car! o 3))))) (f)) '((2 . "RT")))
  (test '(let ((f (lambda () (let ((g (lambda () (cons 1 2)))) (let ((o (g))) (car o)))))) (f)) '((2 . "RT") (5 . "RT")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (set-car! o 3))))) (f)) '((2 . "RT")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (set-cdr! o 3))))) (f)) '((2 . "RT")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-car! o 3)))) (let ((u (g))) (car o))))))) (f)) '((2 . "RT") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-cdr! o 3)))) (let ((u (g))) (car o))))))) (f)) '((2 . "RT") (11 . "PROC")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (set-car! o 3))) (f)))))) (f)) '((2 . "RT")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (set-car! o 3)))) (let ((u (g))) (let ((v (car o))) (f)))))))) (f)) '((2 . "RT") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((o (cons 1 2))) o)))) (let ((p (g))) (car p)))))) (f)) '((2 . "RT") (5 . "RT")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((o (cons 1 2))) o)))) (let ((p (g))) p))))) (f)) '((2 . "RT") (5 . "RT")))
  (test '(let ((g (lambda (p) (set-cdr! p 3)))) (let ((f (lambda () (let ((o (cons 1 2))) (let ((u (g o))) (cdr o)))))) (f))) '((2 . "PROC") (10 . "RT"))) 
  (test '(let ((g (lambda (p) (set-cdr! p 3)))) (letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (g o))) (let ((v (cdr o))) (f))))))) (f))) '((2 . "PROC") (10 . "RT"))) 
  (test '(let ((o (cons 1 2))) (let ((f (lambda (p) p))) (f o))) '((8 . "RT")))
  (test '(let ((g (lambda () (cons 1 2)))) (let ((f (lambda () (g)))) (f))) '((2 . "RT") (9 . "RT")))
  (test '(let ((g (lambda () (cons 1 2)))) (let ((f (lambda (h) (let ((o (h))) (car o))))) (f g))) '((2 . "RT") (9 . "RT")))
  (test '(let ((g (lambda (p) (set-cdr! p 3) ))) (let ((f (lambda (h) (let ((o (cons 1 2))) (let ((u (h o))) (cdr o)))))) (f g))) '((2 . "PROC") (10 . "RT")))
  (test '(let ((g (lambda (p) (set-cdr! p 3) ))) (let ((f (lambda (h) (let ((o (cons 1 2))) (let ((u (h o))) (cdr o)))))) (letrec ((l (lambda () (let ((v (f g))) (l))))) (l)))) '((2 . "PROC") (10 . "RT") (28 . "RT")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((a 123)) a)))) (g))))) (f)) '((2 . "RT") (5 . "RT")))
  (test '(let ((g (lambda () (let ((a 3)) a)))) (let ((f (lambda () (g)))) (f))) '((2 . "RT") (9 . "RT")))
  (test '(let ((g (lambda () (let ((a 3)) a)))) (let ((f (lambda (h) (h)))) (f g))) '((2 . "RT") (9 . "RT")))
  (test '(let ((g (lambda () (let ((a 3)) a)))) (let ((f (lambda (h) (h)))) (letrec ((l (lambda () (let ((u (f g))) (l))))) (l)))) '((2 . "RT") (9 . "RT") (15 . "RT")))
  (test '(let ((x (cons 2 3))) (let ((o (cons 1 x))) (let ((f (lambda () (let ((ox (cdr o))) (set-car! ox 4))))) (f)))) '((14 . "PROC")))
  (test '(let ((f (lambda () (let ((g (lambda () (let ((o (cons 1 2))) (let ((u (cdr o))) (let ((v (set-car! o u))) o)))))) (let ((p (g))) (car p)))))) (f)) '((2 . "RT") (5 . "RT")))
  (test '(let ((z #f)) (let ((x #t)) (let ((f (lambda () z))) (let ((u (f))) (let ((v (set! x z))) (f)))))) '((8 . "RT")))
  (test '(let ((o (cons 1 2))) (let ((f (lambda () (cdr o)))) (let ((u (f))) (let ((v (set-cdr! o 3))) (f))))) '((8 . "OBS")))
  (test '(let ((f (lambda (x) (let ((xx x)) xx)))) (let ((p (f 123))) (f p))) '((2 . "RT")))
  (test '(let ((f (lambda () (let ((x 1)) (let ((g (lambda () x))) (let ((u (g))) (let ((v (set! x 5))) (g)))))))) (f)) '((2 . "RT") (8 . "OBS")))
  (test '(letrec ((f (lambda (n) (let ((p (- n 1))) (f p))))) (f 123)) '((2 . "RT")))
  (test '(let ((o (cons 1 2))) (let ((f (lambda () (let ((g (lambda () (set-cdr! o 3)))) (let ((u (g))) (cdr o)))))) (f))) '((8 . "PROC") (11 . "PROC")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda (p) (set-car! p 3)))) (g o)))))) (f)) '((11 . "PROC") (2 . "RT")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((h (lambda (q) (set-cdr! q 3)))) (let ((g (lambda (p) (h p)))) (g o))))))) (f)) '((2 . "RT") (11 . "PROC") (19 . "PROC")))
  (test '(let ((f (lambda (p) (let ((u (if p (set-car! p 3) (let ((pp (cons 4 5))) (set! p pp))))) p)))) (let ((o (f #f))) (f o))) '((2 . "PROC")))
  (test '(let ((f (lambda () (let ((x 10)) (let ((g (lambda () x))) (let ((u x)) (let ((v (g))) (let ((w (set! x 11))) (g))))))))) (f)) '((2 . "RT") (8 . "OBS")))
  (test '(let ((f (lambda () (let ((o (cons 1 2))) (let ((g (lambda () (car o)))) (let ((u (car o))) (let ((v (g))) (let ((w (set-car! o 3))) (g))))))))) (f)) '((2 . "RT") (11 . "OBS")))
  (test treenode1 '((2 . "RT") (19 . "RT")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (set-car! o 3))) (f)))))) (f)) '((2 . "RT")))
  (test '(letrec ((f (lambda (p) (let ((pp (cons 1 2))) (let ((u (set-car! pp p))) (f pp)))))) (f 3)) '((2 . "RT")))
  (test '(letrec ((f (lambda (p) (let ((o (cons 1 p))) (let ((u (set-car! o 3))) (f o)))))) (f 2)) '((2 . "RT")))
  (test '(letrec ((f (lambda () (let ((o (cons 1 2))) (let ((u (set-car! o 3))) (let ((v (f))) o)))))) (f)) '((2 . "RT")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p (cons 1 2))) (let ((u (set-cdr! p 3))) (let ((v (set! p o))) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "PROC")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p (cons 1 2))) (let ((u (set-cdr! p 3))) (let ((p o)) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "PROC")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p o)) (let ((pp (cons 1 2))) (let ((v (set! p pp))) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "RT")))
  (test '(let ((o (cons 1 2))) (letrec ((f (lambda () (let ((p o)) (let ((pp (cons 1 2))) (let ((p pp)) (let ((w (set-cdr! p 4))) (f)))))))) (f))) '((8 . "RT")))
  )


(include "output.rkt")



