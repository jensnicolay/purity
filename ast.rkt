#lang racket
(provide (all-defined-out))

(struct «lit» (l v) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («lit»-l s1) («lit»-l s2))))
                                              (define hash-proc (lambda (s rhash) («lit»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («lit»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" («lit»-v v))))
(struct «id» (l x) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                                (= («id»-l s1) («id»-l s2))))
                                                           (define hash-proc (lambda (s rhash) («id»-l s)))
                                                           (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («id»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" («id»-x v))))
(struct «quo» (l e) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («quo»-l s1) («quo»-l s2))))
                                              (define hash-proc (lambda (s rhash) («quo»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («quo»-l s))))))
(struct «lam» (l x e) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («lam»-l s1) («lam»-l s2))))
                                              (define hash-proc (lambda (s rhash) («lam»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («lam»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(lambda ~a ~a)" («lam»-x v) («lam»-e v))))  
(struct «app» (l ae aes) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («app»-l s1) («app»-l s2))))
                                              (define hash-proc (lambda (s rhash) («app»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («app»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" (cons («app»-ae v) («app»-aes v)))))
(struct «let» (l x e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («let»-l s1) («let»-l s2))))
                                              (define hash-proc (lambda (s rhash) («let»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («let»-l s)))))
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(let ((~a ~a)) ~a)" («let»-x v) («let»-e0 v) («let»-e1 v))))

(struct «letrec» (l x e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («letrec»-l s1) («letrec»-l s2))))
                                              (define hash-proc (lambda (s rhash) («letrec»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («letrec»-l s)))))
      #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(letrec ((~a ~a)) ~a)" («letrec»-x v) («letrec»-e0 v) («letrec»-e1 v))))

(struct «if» (l ae e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («if»-l s1) («if»-l s2))))
                                              (define hash-proc (lambda (s rhash) («if»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («if»-l s)))))
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(if ~a ~a ~a)" («if»-ae v) («if»-e0 v) («if»-e1 v))))
(struct «set!» (l x ae) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («set!»-l s1) («set!»-l s2))))
                                              (define hash-proc (lambda (s rhash) («set!»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («set!»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(set! ~a ~a)" («set!»-x v) («set!»-ae v))))

(struct «car» (l x) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («car»-l s1) («car»-l s2))))
                                              (define hash-proc (lambda (s rhash) («car»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («car»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(car ~a)" («car»-x v))))

(struct «cdr» (l x) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («cdr»-l s1) («cdr»-l s2))))
                                              (define hash-proc (lambda (s rhash) («cdr»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («cdr»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(cdr ~a)" («cdr»-x v))))

(struct «set-car!» (l x ae) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («set-car!»-l s1) («set-car!»-l s2))))
                                              (define hash-proc (lambda (s rhash) («set-car!»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («set-car!»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(set-car! ~a ~a)" («set-car!»-x v) («set-car!»-ae v))))

(struct «set-cdr!» (l x ae) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («set-cdr!»-l s1) («set-cdr!»-l s2))))
                                              (define hash-proc (lambda (s rhash) («set-cdr!»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («set-cdr!»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(set-cdr! ~a ~a)" («set-cdr!»-x v) («set-cdr!»-ae v))))

(struct «cons» (l ae1 ae2) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («cons»-l s1) («cons»-l s2))))
                                              (define hash-proc (lambda (s rhash) («cons»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («cons»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(cons ~a ~a)" («cons»-ae1 v) («cons»-ae2 v))))

(struct «vector-ref» (l x ae) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («vector-ref»-l s1) («vector-ref»-l s2))))
                                              (define hash-proc (lambda (s rhash) («vector-ref»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («vector-ref»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(vector-ref ~a ~a)" («vector-ref»-x v) («vector-ref»-ae v))))

(struct «vector-set!» (l x ae1 ae2) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («vector-set!»-l s1) («vector-set!»-l s2))))
                                              (define hash-proc (lambda (s rhash) («vector-set!»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («vector-set!»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(vector-set! ~a ~a ~a)" («vector-set!»-x v) («vector-set!»-ae1 v) («vector-set!»-ae2 v))))

(struct «make-vector» (l ae1 ae2) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («make-vector»-l s1) («make-vector»-l s2))))
                                              (define hash-proc (lambda (s rhash) («make-vector»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («make-vector»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(make-vector ~a ~a)" («make-vector»-ae1 v) («make-vector»-ae2 v))))



(define (compile e)
  (define l -1)
  (define (tag!)
    (set! l (add1 l))
    l)
  (define (compile2 e)
    (match e
      ((? symbol? v) («id» (tag!) (symbol->string v)))
      ((? boolean? v) («lit» (tag!) v))
      ((? number? v) («lit» (tag!) v))
      ((? string? v)(«lit» (tag!) v))
      ((? char? v) («lit» (tag!) v))
      (`(quote ,e) («quo» (tag!) e))
      (`(lambda ,x ,e) («lam» (tag!) (map compile2 x) (compile2 e)))
      (`(if ,ae ,e1 ,e2) («if» (tag!) (compile2 ae) (compile2 e1) (compile2 e2)))
      (`(let ((,x ,e0)) ,e1) («let» (tag!) (compile2 x) (compile2 e0) (compile2 e1)))
      (`(letrec ((,x ,e0)) ,e1) («letrec» (tag!) (compile2 x) (compile2 e0) (compile2 e1)))
      (`(set! ,x ,ae) («set!» (tag!) (compile2 x) (compile2 ae)))
      (`(car ,x) («car» (tag!) (compile2 x)))
      (`(cdr ,x) («cdr» (tag!) (compile2 x)))
      (`(cons ,ae1 ,ae2) («cons» (tag!) (compile2 ae1) (compile2 ae2)))
      (`(set-car! ,x ,ae) («set-car!» (tag!) (compile2 x) (compile2 ae)))
      (`(set-cdr! ,x ,ae) («set-cdr!» (tag!) (compile2 x) (compile2 ae)))        
      (`(vector-ref ,x ,ae) («vector-ref» (tag!) (compile2 x) (compile2 ae)))
      (`(vector-set! ,x ,ae1 ,ae2) («vector-set!» (tag!) (compile2 x) (compile2 ae1) (compile2 ae2)))
      (`(make-vector ,ae1 ,ae2) («make-vector» (tag!) (compile2 ae1) (compile2 ae2)))
      (`(,rator . ,rands) («app» (tag!) (compile2 rator) (map compile2 rands)))
      (_ (error "cannot handle expression" e))))
  (compile2 e))
         
(define (ae? e)
  (match e
    ((«lit» _ _) #t)
    ((«id» _ _) #t)
    ((«lam» _ _ _) #t)
    ((«quo» _ e) (not (pair? e))) 
    (_ #f)))

(define (free e)
  (define (f e env)
    (match e
      ((«id» _ x) (if (set-member? env x)
                      (set)
                      (set x)))
      ((«lam» _ x e) (f e (set-union env (list->set (map «id»-x x)))))
      ((«let» _ x e0 e1) (set-union (f e0 env) (f e1 (set-add env («id»-x x)))))
      ((«letrec» _ x e0 e1) (set-union (f e0 (set-add env («id»-x x))) (f e1 (set-add env («id»-x x)))))
      ((«if» _ ae e1 e2) (set-union (f ae env) (f e1 env) (f e2 env)))
      ((«set!» _ x ae) (set-union (f x env) (f ae env)))
      ((«car» _ x) (f x env))
      ((«cdr» _ x) (f x env))
      ((«set-car!» _ x ae) (set-union (f x env) (f ae env)))
      ((«set-cdr!» _ x ae) (set-union (f x env) (f ae env)))
      ((«cons» _ ae1 ae2) (set-union (f ae1 env) (f ae2 env)))
      ((«make-vector» _ ae1 ae2) (set-union (f ae1 env) (f ae2 env)))
      ((«vector-ref» _ x ae) (set-union (f x env) (f ae env)))
      ((«vector-set!» _ x ae1 ae2) (set-union (f x env) (f ae1 env) (f ae2 env)))
      ((«quo» _ _) (set))
      ((«app» _ rator rands) (set-union (f rator env) (for/fold ((xs (set))) ((rand rands)) (set-union xs (f rand env)))))
      ((«id» _ _) (set))
      ((«lit» _ _) (set))
      (_ (error "cannot handle expression" e))))
  (f e (set)))

(define (children e)
  (match e
    ((«id» _ _) (set))
    ((«lit» _ _) (set))
    ((«lam» _ x e) (set-add (list->set x) e))
    ((«let» _ x e0 e1) (set x e0 e1))
    ((«letrec» _ x e0 e1) (set x e0 e1))
    ((«if» _ ae e1 e2) (set ae e1 e2))
    ((«car» _ x) (set x))
    ((«cdr» _ x) (set x))
    ((«set!» _ x ae) (set x ae))
    ((«set-car!» _ x ae) (set x ae))
    ((«set-cdr!» _ x ae) (set x ae))
    ((«cons» _ ae1 ae2) (set ae1 ae2))
    ((«make-vector» _ ae1 ae2) (set ae1 ae2))
    ((«vector-ref» _ x ae) (set x ae))
    ((«vector-set!» _ x ae1 ae2) (set x ae1 ae2))
    ((«quo» _ _) (set))
    ((«app» _ rator rands) (set-add (list->set rands) rator))
    (_ (error "cannot handle expression" e))))


;(define (parent e ast)
;  (let ((cs (children ast)))
;    (if (set-member? cs e)
;        ast
;        (let loop ((cs cs))
;          (if (set-empty? cs)
;              #f
;              (let ((p (parent e (set-first cs))))
;                (or p (loop (set-rest cs)))))))))


(define (parent-map ast)
  (define (traverse-ast S W)
    (if (set-empty? W)
        S
        (let* ((e (set-first W))
               (E* (children e))
               (S* (for/fold ((S S)) ((e* E*))
                     (hash-set S e* e)))
               (W* (set-union (set-rest W) E*)))
          (traverse-ast S* W*))))
  (traverse-ast (hash) (set ast)))

(define (make-parent ast)
  (let ((P (parent-map ast)))
    (lambda (e)
      (hash-ref P e #f))))

(define (nodes ast) (for/fold ((cs (list ast))) ((c (children ast))) (append cs (nodes c))))

