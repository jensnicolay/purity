#lang racket
(provide (all-defined-out))

(struct «lit» (l v) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («lit»-l s1) («lit»-l s2))))
                                              (define hash-proc (lambda (s rhash) («lit»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («lit»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" («lit»-v v))))
(struct «id» (l x) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                                (= («id»-l s1) («id»-l s2))))
                                                           (define hash-proc (lambda (s rhash) («id»-l s)))
                                                           (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («id»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" («id»-x v))))
(struct «quo» (l e) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («quo»-l s1) («quo»-l s2))))
                                              (define hash-proc (lambda (s rhash) («quo»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («quo»-l s))))))
(struct «lam» (l x e) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («lam»-l s1) («lam»-l s2))))
                                              (define hash-proc (lambda (s rhash) («lam»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («lam»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(lambda ~a ~a)" («lam»-x v) («lam»-e v))))  
(struct «app» (l ae aes) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («app»-l s1) («app»-l s2))))
                                              (define hash-proc (lambda (s rhash) («app»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («app»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" (cons («app»-ae v) («app»-aes v)))))
(struct «let» (l x e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («let»-l s1) («let»-l s2))))
                                              (define hash-proc (lambda (s rhash) («let»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («let»-l s)))))
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(let ((~a ~a)) ~a)" («let»-x v) («let»-e0 v) («let»-e1 v))))

(struct «letrec» (l x e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («letrec»-l s1) («letrec»-l s2))))
                                              (define hash-proc (lambda (s rhash) («letrec»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («letrec»-l s)))))
      #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(letrec ((~a ~a)) ~a)" («letrec»-x v) («letrec»-e0 v) («letrec»-e1 v))))

(struct «if» (l ae e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («if»-l s1) («if»-l s2))))
                                              (define hash-proc (lambda (s rhash) («if»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («if»-l s)))))
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(if ~a ~a ~a)" («if»-ae v) («if»-e0 v) («if»-e1 v))))
(struct «set!» (l x ae) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («set!»-l s1) («set!»-l s2))))
                                              (define hash-proc (lambda (s rhash) («set!»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («set!»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(set! ~a ~a)" («set!»-x v) («set!»-ae v))))

(define (compile e)
  (let ((l 0))
    (define (tag!)
      (begin0
        l
        (set! l (add1 l))))
    (define (compile2 e)
      (match e
        ((? symbol? v) («id» (tag!) (symbol->string v)))
        ((? boolean? v) («lit» (tag!) v))
        ((? number? v) («lit» (tag!) v))
        ((? string? v)(«lit» (tag!) v))
        ((? char? v) («lit» (tag!) v))
        (`(quote ,e) («quo» (tag!) e))
        (`(lambda ,x ,e) («lam» (tag!) (map compile2 x) (compile2 e)))
        (`(if ,ae ,e1 ,e2) («if» (tag!) (compile2 ae) (compile2 e1) (compile2 e2)))
        (`(let ((,x ,e0)) ,e1) («let» (tag!) (compile2 x) (compile2 e0) (compile2 e1)))
        (`(letrec ((,x ,e0)) ,e1) («letrec» (tag!) (compile2 x) (compile2 e0) (compile2 e1)))
        (`(set! ,x ,ae) («set!» (tag!) (compile2 x) (compile2 ae)))
        (`(,rator . ,rands) («app» (tag!) (compile2 rator) (map compile2 rands)))
        (_ (error "cannot handle expression" e))))
    (compile2 e)))
         
(define (ae? e)
  (match e
    ((«lit» _ _) #t)
    ((«id» _ _) #t)
    ((«lam» _ _ _) #t)
    ((«quo» _ e) (not (pair? e))) 
    (_ #f)))

(define (free e)
  (define (f e env)
    (match e
      ((«id» _ x) (if (set-member? env x)
                      (set)
                      (set x)))
      ((«lam» _ x e) (f e (set-union env (list->set (map «id»-x x)))))
      ((«let» _ x e0 e1) (set-union (f e0 env) (f e1 (set-add env («id»-x x)))))
      ((«letrec» _ x e0 e1) (set-union (f e0 (set-add env («id»-x x))) (f e1 (set-add env («id»-x x)))))
      ((«if» _ ae e1 e2) (set-union (f ae env) (f e1 env) (f e2 env)))
      ((«set!» _ x ae) (set-union (f x env) (f ae env)))
      ((«quo» _ _) (set))
      ((«app» _ rator rands) (set-union (f rator env) (for/fold ((xs (set))) ((rand rands)) (set-union xs (f rand env)))))
      ((«id» _ _) (set))
      ((«lit» _ _) (set))
      (_ (error "cannot handle expression" e))))
  (f e (set)))

(define (children e)
  (match e
    ((«id» _ x) (set))
    ((«lam» _ x e) (set-add (list->set x) e))
    ((«let» _ x e0 e1) (set x e0 e1))
    ((«letrec» _ x e0 e1) (set x e0 e1))
    ((«if» _ ae e1 e2) (set ae e1 e2))
    ((«set!» _ x ae) (set x ae))
    ((«quo» _ _) (set))
    ((«app» _ rator rands) (set-add (list->set rands) rator))
    ((«id» _ _) (set))
    ((«lit» _ _) (set))
    (_ (error "cannot handle expression" e))))


(define (parent e ast)
  (let ((cs (children ast)))
    (if (set-member? cs e)
        ast
        (let loop ((cs cs))
          (if (set-empty? cs)
              #f
              (let ((p (parent e (set-first cs))))
                (or p (loop (set-rest cs)))))))))


(define (parent-map ast)
  (define (traverse-ast S W)
    (if (set-empty? W)
        S
        (let* ((e (set-first W))
               (E* (children e))
               (S* (for/fold ((S S)) ((e* E*))
                     (hash-set S e* e)))
               (W* (set-union (set-rest W) E*)))
          (traverse-ast S* W*))))
  (traverse-ast (hash) (set ast)))

(define (make-parent ast)
  (let ((P (parent-map ast)))
    (lambda (e)
      (hash-ref P e #f))))


